<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Car • First-Person Cockpit HUD</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background:#111; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; color: #eee; font-family: system-ui, sans-serif; }
    canvas { display:block; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="info">W/S = forward/back • A/D = steer • C = toggle 1st/3rd person</div>

<script type="module">
import * as THREE from 'three';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

//
// ---------- Renderer / Scene / Camera ----------
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
renderer.shadowMap.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x101018);

// Wider FOV + close near-plane so cockpit won’t clip
const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.03, 2000);
camera.position.set(0, 6, 12);
scene.add(camera); // IMPORTANT: add camera so its children (HUD) render

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sun = new THREE.DirectionalLight(0xffffff, 0.9);
sun.position.set(10, 15, 8);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
scene.add(sun);

// ground + grid (for reference)
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(2000, 2000),
  new THREE.MeshStandardMaterial({ color: 0x2b2f3a, roughness: 0.9 })
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

const grid = new THREE.GridHelper(2000, 1000, 0x555a66, 0x2e3340);
grid.material.opacity = 0.25;
grid.material.transparent = true;
scene.add(grid);

//
// ---------- Roads pack (loaded as-is) ----------
const ROADS_ASSETS = '/assets/Roads/';   // change if needed
const ROADS_MTL = 'Roads.mtl';
const ROADS_OBJ = 'Roads.obj';

function setAnisotropy(root) {
  const aniso = renderer.capabilities.getMaxAnisotropy();
  root.traverse(o => {
    if (o.isMesh) {
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      for (const m of mats) if (m && m.map) m.map.anisotropy = aniso;
      o.receiveShadow = true;
      o.castShadow = false;
    }
  });
}

{
  const mtl = new MTLLoader();
  mtl.setPath(ROADS_ASSETS);
  mtl.setResourcePath(ROADS_ASSETS);
  mtl.load(ROADS_MTL, (materials) => {
    materials.preload();
    const obj = new OBJLoader();
    obj.setMaterials(materials);
    obj.setPath(ROADS_ASSETS);
    obj.load(ROADS_OBJ, (root) => {
      setAnisotropy(root);
      root.position.y = 0.02; // avoid z-fighting with ground
      scene.add(root);
    });
  });
}

//
// ---------- Car container & model ----------
const car = new THREE.Group();
scene.add(car);

const CAR_ASSETS = '/assets/Car-Model/'; // change if needed
const CAR_OBJ = 'Car.obj';
const CAR_MTL = 'Car.mtl';

{
  const mtl = new MTLLoader();
  mtl.setPath(CAR_ASSETS);
  mtl.setResourcePath(CAR_ASSETS);
  mtl.load(CAR_MTL, (materials) => {
    materials.preload();
    const objLoader = new OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath(CAR_ASSETS);
    objLoader.load(CAR_OBJ, (obj) => {
      obj.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });
      obj.rotation.y = Math.PI/2; // model faces +X
      obj.scale.setScalar(1.0);
      car.add(obj);
    });
  });
}

//
// ---------- FIRST-PERSON COCKPIT HUD (camera child) ----------
const cockpitRig = new THREE.Group();
camera.add(cockpitRig);

// Black dashboard strip (HUD)
const dashGeom = new THREE.RingGeometry(0.95, 1.85, 64, 1, Math.PI*0.02, Math.PI*0.96);
const dashMat  = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
const dashboard = new THREE.Mesh(dashGeom, dashMat);
dashboard.position.set(0, -0.18, -0.65); // anchored to camera; tweak Y/Z
dashboard.material.depthTest = false;
dashboard.material.depthWrite = false;
dashboard.renderOrder = 999;
cockpitRig.add(dashboard);

// Gray steering wheel (HUD)
const wheelMat = new THREE.MeshStandardMaterial({ color: 0x8a8a8a, metalness: 0.0, roughness: 0.35 });
const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.33, 0.035, 20, 120), wheelMat);
wheel.position.set(0.0, -0.02, -0.72);
wheel.rotation.x = -0.08; // slight tilt
wheel.material.depthTest = false;
wheel.material.depthWrite = false;
wheel.renderOrder = 999;
cockpitRig.add(wheel);

// Optional small hub disk
const hubMat = new THREE.MeshStandardMaterial({ color: 0x6b6b6b, roughness: 0.6, metalness: 0.0 });
const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.02, 24), hubMat);
hub.rotation.x = Math.PI/2;
hub.position.set(0, -0.02, -0.69);
hub.material.depthTest = false;
hub.material.depthWrite = false;
hub.renderOrder = 999;
cockpitRig.add(hub);

// Steering wheel animation state
let wheelVisualAngle = 0;
const MAX_WHEEL_ANGLE = Math.PI/2; // ±90°

//
// ---------- Spawn the car ----------
let firstPerson = true; // start 1st-person so HUD shows
let heading = 0;
car.position.set(-10, 0, 0);
car.rotation.y = heading;

//
// ---------- Controls & kinematics ----------
const keys = new Set();
addEventListener('keydown', (e) => {
  if (['KeyW','KeyA','KeyS','KeyD','KeyC'].includes(e.code)) e.preventDefault();
  keys.add(e.code);
});
addEventListener('keyup', (e) => keys.delete(e.code));

let speed = 0;
const params = {
  accel: 8.0, brake: 12.0, reverseAccel: 6.0,
  maxFwd: 14.0, maxRev: 6.0,
  friction: 3.5, steerRate: 1.8, minSteerFactor: 0.35
};

const chaseOffset = new THREE.Vector3(-6.5, 3.0, 0.0);
const camTarget = new THREE.Vector3();

// First-person camera placement relative to car (world-space)
const FP_EYE_OFFSET = new THREE.Vector3(0.05, 1.55, 0.12); // car-local
const FP_LOOK_AHEAD = 20;
const FP_LOOK_UP    = 0.10;

function update(dt) {
  // Throttle / brake
  if (keys.has('KeyW')) speed += params.accel * dt;
  else if (keys.has('KeyS')) speed += (speed > 0 ? -params.brake : -params.reverseAccel) * dt;
  else {
    const s = Math.sign(speed);
    speed -= s * params.friction * dt;
    if (Math.sign(speed) !== s) speed = 0;
  }
  speed = THREE.MathUtils.clamp(speed, -params.maxRev, params.maxFwd);

  // Steering
  let steerInput = 0;
  if (keys.has('KeyA')) steerInput += 1;
  if (keys.has('KeyD')) steerInput -= 1;
  const steerFactor = THREE.MathUtils.lerp(1.8, params.minSteerFactor, Math.min(Math.abs(speed)/params.maxFwd, 1));
  heading += params.steerRate * steerFactor * steerInput * dt;

  // Integrate car
  const forward = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);
  car.position.addScaledVector(forward, speed * dt);
  car.rotation.set(0, heading, 0);

  // Animate steering wheel (HUD rotates around Z)
  const targetWheel = steerInput * MAX_WHEEL_ANGLE;
  wheelVisualAngle = THREE.MathUtils.damp(wheelVisualAngle, targetWheel, 12, dt);
  wheel.rotation.z = wheelVisualAngle;

  // Toggle view
  if (keys.has('KeyC')) { firstPerson = !firstPerson; keys.delete('KeyC'); }
  cockpitRig.visible = firstPerson;

  // Camera follow
  if (firstPerson) {
    const eyeWorld = FP_EYE_OFFSET.clone()
      .applyAxisAngle(new THREE.Vector3(0,1,0), heading)
      .add(car.position);
    camera.position.lerp(eyeWorld, 0.25);

    camTarget.copy(eyeWorld).addScaledVector(forward, FP_LOOK_AHEAD);
    camTarget.y += FP_LOOK_UP;
    camera.lookAt(camTarget);
  } else {
    const offsetWorld = chaseOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), heading);
    const desiredPos = car.position.clone().add(offsetWorld);
    camera.position.lerp(desiredPos, 0.08);
    camTarget.copy(car.position).addScaledVector(forward, 4.0);
    camera.lookAt(camTarget);
  }
}

//
// ---------- Loop ----------
let last = performance.now();
function tick(now = performance.now()) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();

addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
