<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Driving Grid • Obstacles + Enemy Agents + Health</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#111; overflow:hidden; }
    #info { position:absolute; top:10px; left:10px; color:#eee; font:14px/1.3 system-ui, sans-serif; z-index:7; }
    #minimap {
      position: absolute;
      left: 12px;
      bottom: 12px;
      width: 210px;
      height: 210px;
      border-radius: 50%;
      background: #1c1e22;
      box-shadow: 0 2px 8px rgba(0,0,0,0.45), inset 0 0 0 2px rgba(255,255,255,0.05);
      z-index: 6;
    }

    /* Health bar HUD */
    #healthUI {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 240px;
      height: 18px;
      z-index: 8;
      font: 12px/1 system-ui, sans-serif;
      color: #cfd6dc;
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
    }
    #healthLabel { margin-bottom: 6px; opacity: .9; }
    #healthBar {
      position: relative;
      width: 100%; height: 12px;
      background: rgba(255,255,255,0.08);
      border-radius: 10px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.07), 0 2px 6px rgba(0,0,0,.3);
      overflow: hidden;
    }
    #healthFill {
      position: absolute; left: 0; top: 0; height: 100%;
      width: 100%;
      background: hsl(120, 78%, 45%); /* green -> will tween towards red via JS */
      border-radius: inherit;
      transition: width .15s ease, background-color .15s ease, filter .15s ease;
      filter: drop-shadow(0 0 4px rgba(0,0,0,.35));
    }
    .hp-damage #healthFill { filter: brightness(1.2) saturate(1.2); }

    /* Parcel + toast UI */
    .parcel {
      position: fixed;
      width: 28px; height: 28px;
      background: #8b5a2b;
      border: 2px solid #4e341a;
      border-radius: 4px;
      box-shadow: 0 6px 12px rgba(0,0,0,.4);
      top: -40px;
      left: calc(50% - 14px);
      opacity: 1;
      transform: translateY(0);
      transition:
        transform 1.4s cubic-bezier(.2,.7,.2,1),
        opacity   1.4s linear;
      z-index: 9999;
    }
    #toast {
      position: fixed;
      top: 14%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.75);
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      font: 600 18px/1.3 system-ui, sans-serif;
      letter-spacing: .2px;
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s ease;
      z-index: 10000;
    }
    #toast.show { opacity: 1; }
  </style>

  <!-- Import map -->
  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
  } }
  </script>
</head>
<body>
<div id="info">
  W/S = forward/back • A/D = steer • C = toggle 1st/3rd • L = lamps • N = day/night • H = headlights •
  R = replace placeholders • P = parcel drop • <b>B</b> = roadblock ahead • <b>E</b> = spawn pursuer
</div>

<!-- Health HUD -->
<div id="healthUI">
  <div id="healthLabel">Health</div>
  <div id="healthBar"><div id="healthFill"></div></div>
</div>

<canvas id="minimap"></canvas>
<div id="toast" aria-live="polite"></div>

<script type="module">
import * as THREE from 'three';
import { OBJLoader }  from 'three/addons/loaders/OBJLoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

/* -------------------- Asset paths -------------------- */
const WH_PATH = 'assets/50-ware-house/';
const WH_OBJ  = 'ware house.obj';

/* Vehicle (GLB) */
const VEHICLE_PATH = 'assets/';
const TRUCK_GLB    = 'Pickup Truck.glb';

/* Buildings */
const BLD_PATH  = 'assets/';
const LARGE_GLB = 'Large Building.glb';
const SMALL_GLB = 'Small Building.glb';
/* ----------------------------------------------------- */

/* ===================== RENDERER (perf settings) ===================== */
const renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:'high-performance' });
renderer.setSize(innerWidth, innerHeight);
const START_DPR = Math.min(2, devicePixelRatio || 1);
renderer.setPixelRatio(START_DPR);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMappingExposure = 1.0;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.BasicShadowMap;
document.body.appendChild(renderer.domElement);

/* ===================== SCENE / CAMERA / LIGHTS ===================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x101018);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.03, 2000);
camera.position.set(0,6,12);
scene.add(camera);

const amb = new THREE.AmbientLight(0xffffff, 0.45);
scene.add(amb);

const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(25,35,10);
sun.castShadow = true;
sun.shadow.mapSize.set(512,512);
scene.add(sun);

const SHADOW_HALF_EXTENT = 90;
Object.assign(sun.shadow, {
  camera: new THREE.OrthographicCamera(-SHADOW_HALF_EXTENT, SHADOW_HALF_EXTENT, SHADOW_HALF_EXTENT, -SHADOW_HALF_EXTENT, 0.5, 400)
});
scene.add(sun.shadow.camera);

/* ===================== WORLD BASE ===================== */
const MAP_SIZE = 1200, MAP_HALF = MAP_SIZE/2;

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE),
  new THREE.MeshLambertMaterial({ color:0xcfcfcf })
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

const divisions = Math.max(2, Math.round(MAP_SIZE/6));
const grid = new THREE.GridHelper(MAP_SIZE, divisions, 0x000000, 0x000000);
grid.material.transparent = true;
grid.material.opacity = 0.45;
grid.position.y = 0.0005;
scene.add(grid);

/* ===================== ROAD / CROSSWALK TILES ===================== */
const ROAD_COLOR  = 0x2b2b2b;
const BASE_HEIGHT = 0.02;
const JOIN_EPS    = 1.0;
const ROAD_WIDTH  = 10, ROAD_LEN = 32, XWALK_LEN = 14;

function createRoadTile({length=32, width=10, baseHeight=BASE_HEIGHT, edgeWidth=0.18, dashLength=2.2, dashWidth=0.28}={}){
  const g = new THREE.Group();
  const asphalt = new THREE.Mesh(new THREE.PlaneGeometry(length, width), new THREE.MeshLambertMaterial({ color:ROAD_COLOR }));
  asphalt.rotation.x = -Math.PI/2; asphalt.position.y = baseHeight; asphalt.receiveShadow = true; g.add(asphalt);
  const makeStrip = (L,W,color)=>{ const m=new THREE.Mesh(new THREE.PlaneGeometry(L,W), new THREE.MeshBasicMaterial({color,side:THREE.DoubleSide})); m.rotation.x=-Math.PI/2; m.position.y=baseHeight+0.001; return m; };
  const edgeOffset = width/2 - edgeWidth/2;
  const left  = makeStrip(length, edgeWidth, 0xFFC107); left.position.z  =  edgeOffset;
  const right = makeStrip(length, edgeWidth, 0xFFC107); right.position.z = -edgeOffset;
  g.add(left, right);
  const gap = length/4;
  for (const x of [-gap,0,gap]) { const dash = makeStrip(dashLength, dashWidth, 0xFFFFFF); dash.position.x = x; g.add(dash); }
  return g;
}

function createCrosswalkTile({
  length=14, width=10, baseHeight=BASE_HEIGHT,
  edgeMargin=0.6, stubDepth=0.9, stripeThickness=0.28, gap=0.95,
  apronDepth=0.55, apronBleedX=1.20
} = {}) {
  const g = new THREE.Group();
  const base = new THREE.Mesh(new THREE.PlaneGeometry(length + 2*JOIN_EPS, width + 2*JOIN_EPS), new THREE.MeshLambertMaterial({ color:ROAD_COLOR }));
  base.rotation.x = -Math.PI/2; base.position.y = baseHeight; base.receiveShadow = true; g.add(base);
  const makeStrip = (L,W)=>{ const m=new THREE.Mesh(new THREE.PlaneGeometry(L,W), new THREE.MeshBasicMaterial({ color:0xFFFFFF, side:THREE.DoubleSide })); m.rotation.x=-Math.PI/2; m.position.y=baseHeight+0.0015; return m; };
  const usableX = length - 2*edgeMargin, usableZ = width - 2*edgeMargin;
  const countX = Math.max(2, Math.floor((usableX + gap)/(stripeThickness+gap)));
  const countZ = Math.max(2, Math.floor((usableZ + gap)/(stripeThickness+gap)));
  const startX = -length/2 + edgeMargin + stripeThickness/2;
  const startZ = -width/2  + edgeMargin + stripeThickness/2;
  for (let i=0;i<countX;i++){ const x=startX+i*(stripeThickness+gap);
    const top=makeStrip(stripeThickness, stubDepth); top.position.set(x, base.position.y+0.0015,  width/2 - stubDepth/2);
    const bot=makeStrip(stripeThickness, stubDepth); bot.position.set(x, base.position.y+0.0015, -width/2 + stubDepth/2); g.add(top,bot);
  }
  for (let j=0;j<countZ;j++){ const z=startZ+j*(stripeThickness+gap);
    const left =makeStrip(stubDepth, stripeThickness); left.position.set(-length/2 + stubDepth/2, base.position.y+0.0015, z);
    const right=makeStrip(stubDepth, stripeThickness); right.position.set( length/2 - stubDepth/2, base.position.y+0.0015, z); g.add(left,right);
  }
  const apronY = baseHeight - 0.0005, apronX = length + 2*JOIN_EPS + 2*apronBleedX;
  const apronGeo = new THREE.PlaneGeometry(apronX, apronDepth), apronMat = new THREE.MeshLambertMaterial({ color: ROAD_COLOR });
  const apronTop = new THREE.Mesh(apronGeo, apronMat); apronTop.rotation.x=-Math.PI/2; apronTop.position.set(0, apronY,  width/2 + apronDepth/2);
  const apronBot = apronTop.clone(); apronBot.position.z = -width/2 - apronDepth/2; g.add(apronTop, apronBot);
  return g;
}

/* ===================== Street lamp system ===================== */
const streetLights = [], streetBulbs = []; let streetLightsOn = false;
function createStreetLamp({ side="left", x=0, z=0 }) {
  const sideSign = side === "left" ? +1 : -1;
  const g = new THREE.Group();
  const teal=0x17a08f;
  const poleMat  = new THREE.MeshStandardMaterial({ color:teal, roughness:0.9, metalness:0.05 });
  const shadeMat = new THREE.MeshStandardMaterial({ color:teal, roughness:0.8, metalness:0.1 });
  const bulbMat  = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xffd45a, emissiveIntensity:0.35 });
  const H=5.2, r=0.07, baseR=0.14, baseH=0.25, inward=-sideSign;
  const pts=[ new THREE.Vector3(0,0,0), new THREE.Vector3(0,H*0.6,0), new THREE.Vector3(0,H*1.00,inward*0.5),
              new THREE.Vector3(0,H*1.05,inward*1.3), new THREE.Vector3(0,H*0.85,inward*1.7)];
  const curve=new THREE.CatmullRomCurve3(pts,false,'catmullrom',0.0);
  const arm=new THREE.Mesh(new THREE.TubeGeometry(curve,24,r,10,false),poleMat); arm.castShadow=arm.receiveShadow=true; g.add(arm);
  const foot=new THREE.Mesh(new THREE.CylinderGeometry(baseR,baseR,baseH,18),poleMat); foot.position.y=baseH/2; foot.castShadow=foot.receiveShadow=true; g.add(foot);
  const headPos=curve.getPoint(0.98);
  const bulb=new THREE.Mesh(new THREE.SphereGeometry(0.18,16,12),bulbMat); bulb.position.copy(headPos).add(new THREE.Vector3(0,-0.12,0)); g.add(bulb);
  const shade=new THREE.Mesh(new THREE.ConeGeometry(0.45,0.5,18),shadeMat); shade.rotation.x=Math.PI; shade.position.copy(headPos).add(new THREE.Vector3(0,0.05,0)); shade.castShadow=shade.receiveShadow=true; g.add(shade);
  const lamp=new THREE.PointLight(0xffd45a,0.25,9,2); lamp.position.copy(bulb.position); lamp.castShadow=false; g.add(lamp);
  streetLights.push(lamp); streetBulbs.push(bulb); g.position.set(x,0,z); return g;
}
function setStreetLights(on){ streetLightsOn=on; for(const L of streetLights)L.intensity=on?2.0:0.25; for(const b of streetBulbs)b.material.emissiveIntensity=on?2.2:0.35; }

/* ===================== Car group + headlights ===================== */
const car = new THREE.Group();
scene.add(car);

const headlightRig = new THREE.Group();
car.add(headlightRig);
let headlightBulbs=[], headlightSpots=[], beamMeshes=[], headlightsOn=false;

function clearHeadlights(){ headlightRig.clear(); headlightBulbs.length=0; headlightSpots.length=0; beamMeshes.length=0; }
function rebuildHeadlightsFromBox(box){
  clearHeadlights();
  const size = new THREE.Vector3(); box.getSize(size);
  const min = box.min, max = box.max;
  const frontX = max.x - 0.05*size.x;
  const y = min.y + 0.42*size.y;
  const zOff = 0.28*size.z;

  const bulbMat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xfff2cc, emissiveIntensity:0.20 });
  function makeOne(zSign){
    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.07,14,12), bulbMat);
    bulb.position.set(frontX, y, zSign*zOff);
    const spot = new THREE.SpotLight(0xfff6d5, 0.0, 70, THREE.MathUtils.degToRad(26), 0.35, 1.4);
    spot.position.copy(bulb.position);
    const target = new THREE.Object3D();
    target.position.set(frontX + 16, y - 0.40, zSign*zOff);
    headlightRig.add(target);
    spot.target = target;
    headlightRig.add(bulb, spot);
    headlightBulbs.push(bulb); headlightSpots.push(spot);
    const coneLen = 7.5, coneRad = Math.tan(spot.angle) * coneLen;
    const coneGeo = new THREE.ConeGeometry(coneRad, coneLen, 24, 1, true);
    const coneMat = new THREE.MeshBasicMaterial({ transparent:true, opacity:0.09, depthWrite:false, color:0xfff2cc });
    const cone = new THREE.Mesh(coneGeo, coneMat);
    cone.position.copy(bulb.position); cone.rotation.z = Math.PI/2; cone.rotateX(-0.40);
    headlightRig.add(cone); beamMeshes.push(cone);
  }
  makeOne(+1); makeOne(-1);
  setHeadlights(headlightsOn);
}
function setHeadlights(on){
  headlightsOn = on;
  for(const s of headlightSpots) s.intensity = on ? 8.5 : 0.0;
  for(const b of headlightBulbs) b.material.emissiveIntensity = on ? 1.8 : 0.20;
  for(const mesh of beamMeshes) mesh.visible = on;
}

/* ===== Load Pickup Truck (GLB) and fit it ===== */
{
  const loader = new GLTFLoader().setPath(VEHICLE_PATH);
  loader.load(TRUCK_GLB, (gltf)=>{
    const truck = gltf.scene;
    truck.traverse(o=>{
      if (o.isMesh){
        o.castShadow = o.receiveShadow = true;
        if (o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
      }
    });
    truck.rotation.y = Math.PI/2; // face +X
    let box = new THREE.Box3().setFromObject(truck);
    const size = new THREE.Vector3(); box.getSize(size);
    const targetLen = 3.9;
    const s = targetLen / Math.max(1e-6, size.x);
    truck.scale.setScalar(s);
    box = new THREE.Box3().setFromObject(truck);
    truck.position.y = -box.min.y;
    car.add(truck);
    rebuildHeadlightsFromBox(box);
  }, undefined, ()=>{
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.7,0.9), new THREE.MeshStandardMaterial({ color:0x888888 }));
    body.position.y = 0.35; body.castShadow = body.receiveShadow = true; car.add(body);
    const box = new THREE.Box3().setFromObject(body);
    rebuildHeadlightsFromBox(box);
  });
}

/* ===================== BUILDINGS, LOD & streaming ===================== */
let LARGE_PREFAB = null, LARGE_H = 1;
let SMALL_PREFAB = null, SMALL_H = 1;

function loadGLB(path, filename) {
  return new Promise((resolve) => {
    new GLTFLoader().setPath(path).load(filename, (gltf)=>{
      const obj = gltf.scene;
      obj.traverse(o=>{
        if (o.isMesh){
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for (const m of mats){
            if (!m) continue;
            if ('wireframe' in m) m.wireframe = false;
            if (m.map){
              m.map.colorSpace = THREE.SRGBColorSpace;
              m.map.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
              m.map.needsUpdate = true;
            }
          }
          o.castShadow = o.receiveShadow = true;
        }
      });
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3(); box.getSize(size);
      const height = Math.max(1e-6, size.y);
      obj.position.y = -box.min.y;
      resolve({ root: obj, height });
    }, undefined, (err)=>{ console.warn('GLB load failed:', filename, err); resolve(null); });
  });
}
function makeBuildingClone(targetHeight=20, preferSmall=false){
  const haveSmall = !!SMALL_PREFAB, haveLarge = !!LARGE_PREFAB;
  let src = null, srcH = 1;
  if (preferSmall && haveSmall) { src = SMALL_PREFAB; srcH = SMALL_H; }
  else if (haveLarge)          { src = LARGE_PREFAB; srcH = LARGE_H; }
  else if (haveSmall)          { src = SMALL_PREFAB; srcH = SMALL_H; }
  if (!src) {
    const h = targetHeight, w = 10, d = 10;
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshLambertMaterial({ color:0x9a9a9a }));
    m.position.y = h/2; m.castShadow = m.receiveShadow = true; return m;
  }
  const g = src.clone(true); const s = targetHeight / srcH; g.scale.setScalar(s);
  g.traverse(o=>{
    if (o.isMesh) {
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      if (!o.userData.stdMat) {
        o.userData.stdMat = mats[0];
        const basicOpts = { map: mats[0]?.map ?? null, color: mats[0]?.color ? mats[0].color.clone() : new THREE.Color(0xffffff), side: mats[0]?.side ?? THREE.FrontSide };
        o.userData.basicMat = new THREE.MeshBasicMaterial(basicOpts);
        if (basicOpts.map) basicOpts.map.colorSpace = THREE.SRGBColorSpace;
      }
      o.castShadow = true; o.receiveShadow = true;
    }
  });
  return g;
}

const roadSegments = [];
function rememberSegment(x,z,isX){ roadSegments.push({x,z,isX}); }

const ACTIVE_RADIUS = 180, HYST=30, SIDEWALK_CLEAR=14.0;

const active = new Map(); const pool=[];
function segKey(s){ return `${s.isX?'X':'Z'}:${s.x|0}:${s.z|0}`; }

function isBoxMesh(m){ return m?.isMesh && m.geometry?.isBoxGeometry; }
function upgradeMeshToGLB(oldMesh, targetHeight){
  if (!LARGE_PREFAB && !SMALL_PREFAB) return oldMesh;
  const repl = makeBuildingClone(targetHeight, false);
  repl.position.copy(oldMesh.position); repl.rotation.y = oldMesh.rotation?.y || 0;
  oldMesh.parent?.add(repl); oldMesh.parent?.remove(oldMesh);
  repl.updateWorldMatrix(true,true);
  repl.userData.aabb = makeAABBFor(repl);
  return repl;
}
function upgradePairIfNeeded(pair){
  if (!pair) return;
  if (isBoxMesh(pair.b1)) pair.b1 = upgradeMeshToGLB(pair.b1, 22);
  if (isBoxMesh(pair.b2)) pair.b2 = upgradeMeshToGLB(pair.b2, 18);
}
function setObjLit(obj, lit, cast){
  obj.traverse(o=>{
    if (o.isMesh) {
      if (o.userData.stdMat && o.userData.basicMat) o.material = lit ? o.userData.stdMat : o.userData.basicMat;
      o.castShadow = !!cast;
    }
  });
}
function applyLOD(pair, dist){
  if (dist < 90){ setObjLit(pair.b1,true,true); setObjLit(pair.b2,true,true); }
  else if (dist < 150){ setObjLit(pair.b1,true,false); setObjLit(pair.b2,true,false); }
  else { setObjLit(pair.b1,false,false); setObjLit(pair.b2,false,false); }
}
function spawnPair(s, preferSmall=false){
  let pair = pool.pop();
  if (!pair) pair = { b1: makeBuildingClone(22, preferSmall), b2: makeBuildingClone(18, preferSmall) };
  else {
    if (isBoxMesh(pair.b1)) pair.b1 = makeBuildingClone(22, preferSmall);
    if (isBoxMesh(pair.b2)) pair.b2 = makeBuildingClone(18, preferSmall);
  }
  const off = ROAD_WIDTH/2 + SIDEWALK_CLEAR;
  if (s.isX){ pair.b1.position.set(s.x,0,s.z+off); pair.b2.position.set(s.x+10,0,s.z-off); }
  else      { pair.b1.position.set(s.x+off,0,s.z); pair.b2.position.set(s.x-off,0,s.z+10); }
  pair.b1.rotation.y = (Math.PI/2) * (Math.random()*4|0);
  pair.b2.rotation.y = (Math.PI/2) * (Math.random()*4|0);
  pair.b1.updateWorldMatrix(true,true); pair.b2.updateWorldMatrix(true,true);
  pair.b1.userData.aabb = makeAABBFor(pair.b1); pair.b2.userData.aabb = makeAABBFor(pair.b2);
  const d = Math.hypot(car.position.x - s.x, car.position.z - s.z); applyLOD(pair, d);
  scene.add(pair.b1, pair.b2); active.set(segKey(s), pair);
}
function despawnPair(key){ const pair=active.get(key); if(!pair)return; scene.remove(pair.b1,pair.b2); pool.push(pair); active.delete(key); }
let streamingEnabled=false;
function updateStreaming(nowMs){
  if (!streamingEnabled) return;
  if (!updateStreaming.last) updateStreaming.last=0;
  if (nowMs - updateStreaming.last < 250) return;
  updateStreaming.last = nowMs;

  for (const s of roadSegments){
    const d = Math.hypot(car.position.x - s.x, car.position.z - s.z);
    const key = segKey(s), isActive = active.has(key);
    if (!isActive && d < ACTIVE_RADIUS) spawnPair(s,false);
    if (isActive && d > ACTIVE_RADIUS + HYST) despawnPair(key);
  }
  for (const [key,pair] of active){
    const [,x,z] = key.split(':').map(Number);
    const d = Math.hypot(car.position.x - x, car.position.z - z);
    applyLOD(pair, d);
  }
}

/* ===================== Collisions ===================== */
const CAR_RADIUS = 0.9;
function box3ToAABB2D(box){ return { minX:box.min.x, maxX:box.max.x, minZ:box.min.z, maxZ:box.max.z }; }
function makeAABBFor(obj){ const b = new THREE.Box3().setFromObject(obj); return box3ToAABB2D(b); }
function circleAABBResolve(cx,cz,r,aabb){
  const qx = Math.min(Math.max(cx, aabb.minX), aabb.maxX);
  const qz = Math.min(Math.max(cz, aabb.minZ), aabb.maxZ);
  const dx=cx-qx, dz=cz-qz, d2=dx*dx+dz*dz;
  if (d2 > r*r) return null;
  const inside = (cx>=aabb.minX && cx<=aabb.maxX && cz>=aabb.minZ && cz<=aabb.maxZ);
  if (inside){
    const l=cx-aabb.minX, rgt=aabb.maxX-cx, t=cz-aabb.minZ, b=aabb.maxZ-cz;
    const m=Math.min(l,rgt,t,b);
    if (m===l) return {x:r, z:0}; if (m===rgt) return {x:-r,z:0}; if (m===t) return {x:0,z:r}; return {x:0,z:-r};
  }
  const dist=Math.sqrt(Math.max(d2,1e-12)), pen=r-dist;
  return { x:(dx/dist)*pen, z:(dz/dist)*pen };
}

/* ===================== Obstacles (roadblocks) ===================== */
const obstacles = []; // { mesh, aabb, center:{x,z} }
function addRoadblockAt(x, z, isX = true) {
  const width = ROAD_WIDTH + 2.0;   // along the road
  const thickness = 0.6;            // across the road
  const height = 0.9;
  const mat = new THREE.MeshStandardMaterial({ color: 0xa33a3a, metalness: 0.1, roughness: 0.9 });
  const geo = isX ? new THREE.BoxGeometry(width, height, thickness)
                  : new THREE.BoxGeometry(thickness, height, width);
  const block = new THREE.Mesh(geo, mat);
  block.position.set(x, BASE_HEIGHT + height/2, z);
  block.castShadow = block.receiveShadow = true;
  scene.add(block);
  const aabb = makeAABBFor(block);
  obstacles.push({
    mesh: block,
    aabb,
    center: { x: (aabb.minX + aabb.maxX) * 0.5, z: (aabb.minZ + aabb.maxZ) * 0.5 }
  });
  return block;
}
function spawnRoadblockAhead() {
  const forward = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);
  const ahead = car.position.clone().addScaledVector(forward, 24);
  const xDominant = Math.abs(forward.x) >= Math.abs(forward.z);
  addRoadblockAt(ahead.x, ahead.z, xDominant);
}

/* Merge buildings + obstacles into collision set */
function getNearbyAABBs(cx, cz, radius = 50) {
  const out = [];
  // Buildings
  for (const [key, pair] of active) {
    const parts = key.split(':');
    const px = Number(parts[1]), pz = Number(parts[2]);
    if ((cx - px)**2 + (cz - pz)**2 > radius*radius) continue;
    if (pair.b1?.userData?.aabb) out.push(pair.b1.userData.aabb);
    if (pair.b2?.userData?.aabb) out.push(pair.b2.userData.aabb);
  }
  // Obstacles
  for (const o of obstacles) {
    const dx = cx - o.center.x, dz = cz - o.center.z;
    if (dx*dx + dz*dz <= radius*radius) out.push(o.aabb);
  }
  return out;
}

/* Generic circle collider resolver + car wrapper */
function resolveCircleCollisions(pos, radius) {
  for (let it=0; it<4; it++) {
    const aabbs = getNearbyAABBs(pos.x, pos.z, 60);
    let pushed = false;
    for (const a of aabbs) {
      const push = circleAABBResolve(pos.x, pos.z, radius, a);
      if (push) { pos.x += push.x; pos.z += push.z; pushed = true; }
    }
    if (!pushed) break;
  }
  return pos;
}
function resolveCarCollisions(proposed) { return resolveCircleCollisions(proposed, CAR_RADIUS); }

/* ===================== Pursuer agents (enemy cars) ===================== */
const agents = []; // array of agent objects
function spawnPursuer(x, z) {
  const L = 3.0, H = 0.7, W = 1.6;
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(L, H, W),
    new THREE.MeshStandardMaterial({ color: 0xD32F2F, metalness: 0.1, roughness: 0.6 })
  );
  mesh.position.set(x, H/2, z);
  mesh.castShadow = mesh.receiveShadow = true;
  scene.add(mesh);
  const agent = {
    mesh,
    vel: new THREE.Vector3(),
    maxSpeed: 11,
    maxAccel: 18,
    radius: 0.9
  };
  agents.push(agent);
  return agent;
}
function spawnPursuerBehind() {
  const back = car.position.clone().add(new THREE.Vector3(-20, 0, 0));
  spawnPursuer(back.x, back.z);
}
// avoidance field from nearby AABBs
function avoidanceAccel(pos, maxAccel) {
  const aabbs = getNearbyAABBs(pos.x, pos.z, 40);
  const out = new THREE.Vector3();
  for (const b of aabbs) {
    const cx = THREE.MathUtils.clamp(pos.x, b.minX, b.maxX);
    const cz = THREE.MathUtils.clamp(pos.z, b.minZ, b.maxZ);
    let dx = pos.x - cx, dz = pos.z - cz;
    const d2 = dx*dx + dz*dz;
    const r = 2.4;
    if (d2 > 1e-6 && d2 < r*r) {
      const d = Math.sqrt(d2);
      const strength = (r - d) / r;
      dx /= d; dz /= d;
      out.x += dx * maxAccel * 1.2 * strength;
      out.z += dz * maxAccel * 1.2 * strength;
    }
  }
  return out;
}
function updateAgents(dt) {
  const carForward = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);
  const prediction = car.position.clone().addScaledVector(carForward, 4 + Math.abs(speed)*0.5);

  for (const a of agents) {
    const desired = prediction.clone().sub(a.mesh.position).setY(0);
    const dist = desired.length();
    if (dist > 1e-6) desired.multiplyScalar(a.maxSpeed / dist);

    const steer = desired.sub(a.vel).add( avoidanceAccel(a.mesh.position, a.maxAccel) );
    const sl = steer.length(); if (sl > a.maxAccel) steer.multiplyScalar(a.maxAccel / sl);

    a.vel.addScaledVector(steer, dt);
    const vl = a.vel.length(); if (vl > a.maxSpeed) a.vel.multiplyScalar(a.maxSpeed / vl);

    const proposed = a.mesh.position.clone().addScaledVector(a.vel, dt);
    const fixed = resolveCircleCollisions(proposed, a.radius);
    a.mesh.position.copy(fixed);

    if (a.vel.lengthSq() > 0.01) a.mesh.rotation.y = Math.atan2(a.vel.z, a.vel.x);
  }
}

/* ========= Car ↔ Pursuer collisions + player damage ========= */
let health = 100;
const DAMAGE_COOLDOWN_MS = 700;
let nextDamageAt = 0;
const healthUI = {
  wrap: document.getElementById('healthUI'),
  fill: document.getElementById('healthFill')
};
function setHealthBar(h){
  h = Math.max(0, Math.min(100, h));
  const hue = (h * 120) / 100; // 0=red..120=green
  healthUI.fill.style.width = `${h}%`;
  healthUI.fill.style.background = `hsl(${hue}, 78%, 45%)`;
}
setHealthBar(health);

function flashDamage(){
  healthUI.wrap.classList.add('hp-damage');
  setTimeout(()=> healthUI.wrap.classList.remove('hp-damage'), 140);
}
function applyDamage(amount){
  if (health <= 0) return;
  health = Math.max(0, health - amount);
  setHealthBar(health);
  flashDamage();
  if (health === 0) showToast('vehicle disabled!', 2500);
}
const tmpV = new THREE.Vector3();
let carVelVec = new THREE.Vector3();

function handleCarAgentCollisions(dt){
  const now = performance.now();
  for (const a of agents) {
    const dx = car.position.x - a.mesh.position.x;
    const dz = car.position.z - a.mesh.position.z;
    const d2 = dx*dx + dz*dz;
    const minDist = CAR_RADIUS + a.radius;

    if (d2 < minDist*minDist) {
      // normal
      let d = Math.sqrt(Math.max(d2, 1e-12));
      let nx = dx / d, nz = dz / d;

      // separate both half the overlap
      const overlap = (minDist - d);
      car.position.x += nx * (overlap * 0.5);
      car.position.z += nz * (overlap * 0.5);
      a.mesh.position.x -= nx * (overlap * 0.5);
      a.mesh.position.z -= nz * (overlap * 0.5);

      // simple velocity response: push enemy away and slow car a bit on impact
      // agent push:
      a.vel.x -= nx * 6.5;
      a.vel.z -= nz * 6.5;
      // car speed reduce along normal
      const impactAlong = carVelVec.x * nx + carVelVec.z * nz; // signed
      if (impactAlong > 0) {
        // dampen car forward speed on impact
        speed = Math.max(0, speed - Math.min(impactAlong, 4.0));
      }

      // damage (cooldown to avoid instant drain)
      if (now >= nextDamageAt) {
        // relative speed along normal
        const relNx = (carVelVec.x - a.vel.x) * nx + (carVelVec.z - a.vel.z) * nz;
        const relSpd = Math.abs(relNx);
        const dmg = THREE.MathUtils.clamp(4 + relSpd * 0.9, 6, 18); // 6..18
        applyDamage(dmg|0);
        nextDamageAt = now + DAMAGE_COOLDOWN_MS;
      }
    }
  }
}

/* ===================== Interconnected grid of roads ===================== */
const PERIOD = 3*ROAD_LEN + XWALK_LEN;
function makeCenters(min,max){ const first=min + ROAD_LEN*3.5 + XWALK_LEN/2; const last=max - (ROAD_LEN + XWALK_LEN/2); const arr=[]; for(let c=first; c<=last+1e-6; c+=PERIOD) arr.push(c); return arr; }
const xs = makeCenters(-MAP_HALF, +MAP_HALF);
const zs = makeCenters(-MAP_HALF, +MAP_HALF);

function placeCrosswalk(x,z,rot90=false){ const m = createCrosswalkTile({ length:XWALK_LEN + 2*JOIN_EPS, width:ROAD_WIDTH + 2*JOIN_EPS, baseHeight:BASE_HEIGHT }); m.position.set(x,0,z); if (rot90) m.rotation.y=Math.PI/2; scene.add(m); }
function placeThreeRoadsX(x1,x2,z){ const L=ROAD_LEN+JOIN_EPS; const start=x1+(XWALK_LEN/2)+(ROAD_LEN/2)-JOIN_EPS/2; for(let i=0;i<3;i++){ const cx=start + i*ROAD_LEN; const r=createRoadTile({length:L,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.position.set(cx,0,z); scene.add(r); rememberSegment(cx,z,true); } }
function placeThreeRoadsZ(z1,z2,x){ const L=ROAD_LEN+JOIN_EPS; const start=z1+(XWALK_LEN/2)+(ROAD_LEN/2)-JOIN_EPS/2; for(let i=0;i<3;i++){ const cz=start + i*ROAD_LEN; const r=createRoadTile({length:L,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.rotation.y=Math.PI/2; r.position.set(x,0,cz); scene.add(r); rememberSegment(x,cz,false); } }
for (const z of zs){ xs.forEach(x=>placeCrosswalk(x,z)); for(let i=0;i<xs.length-1;i++) placeThreeRoadsX(xs[i], xs[i+1], z); }
for (const x of xs){ for(let j=0;j<zs.length-1;j++) placeThreeRoadsZ(zs[j], zs[j+1], x); }
for (const z of zs){
  const firstX=xs[0], lastX=xs.at(-1);
  let cx=firstX-(XWALK_LEN/2)-(ROAD_LEN/2)+JOIN_EPS/2;
  for(let i=0;i<3;i++){ const x=cx - i*ROAD_LEN; const r=createRoadTile({length:ROAD_LEN+JOIN_EPS,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.position.set(x,0,z); scene.add(r); rememberSegment(x,z,true); }
  cx=lastX+(XWALK_LEN/2)+(ROAD_LEN/2)-JOIN_EPS/2;
  for(let i=0;i<3;i++){ const x=cx + i*ROAD_LEN; const r=createRoadTile({length:ROAD_LEN+JOIN_EPS,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.position.set(x,0,z); scene.add(r); rememberSegment(x,z,true); }
}
for (const x of xs){
  const firstZ=zs[0], lastZ=zs.at(-1);
  let cz=firstZ-(XWALK_LEN/2)-(ROAD_LEN/2)+JOIN_EPS/2;
  for(let i=0;i<3;i++){ const z=cz - i*ROAD_LEN; const r=createRoadTile({length:ROAD_LEN+JOIN_EPS,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.rotation.y=Math.PI/2; r.position.set(x,0,z); scene.add(r); rememberSegment(x,z,false); }
  cz=lastZ+(XWALK_LEN/2)+(ROAD_LEN/2)-JOIN_EPS/2;
  for(let i=0;i<3;i++){ const z=cz + i*ROAD_LEN; const r=createRoadTile({length:ROAD_LEN+JOIN_EPS,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.rotation.y=Math.PI/2; r.position.set(x,0,z); scene.add(r); rememberSegment(x,z,false); }
}

/* ===================== Spawn (car) ===================== */
const spawnZ = zs[Math.floor(zs.length/2)];
const firstRoadStartX = (-MAP_HALF) + ROAD_LEN;
const carStartX = firstRoadStartX - 0.4*ROAD_LEN;
let firstPerson = true;
let heading = 0;
car.position.set(carStartX, 0, spawnZ);
car.rotation.y = heading;

/* ===================== Street lamps near start ===================== */
{
  const offsetX = 3.0;
  const sideGap = ROAD_WIDTH/2 + 1.6;
  const leftLamp  = createStreetLamp({ side:"left",  x:carStartX + offsetX, z:spawnZ + sideGap });
  const rightLamp = createStreetLamp({ side:"right", x:carStartX + offsetX, z:spawnZ - sideGap });
  scene.add(leftLamp, rightLamp);
  setStreetLights(false);
}

/* ===================== Warehouse behind the car ===================== */
function loadOBJ(path, obj){ return new Promise((res,rej)=> new OBJLoader().setPath(path).load(obj,res,undefined,rej)); }
const WAREHOUSE_DISTANCE_BEHIND = 40, WAREHOUSE_TARGET_LONGEST = 60;
loadOBJ(WH_PATH, WH_OBJ).then((wh)=>{
  wh.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; if(!o.material) o.material=new THREE.MeshLambertMaterial({ color:0x888888 }); } });
  const box=new THREE.Box3().setFromObject(wh); const size=new THREE.Vector3(); box.getSize(size);
  const s= WAREHOUSE_TARGET_LONGEST / Math.max(1e-6, Math.max(size.x,size.y,size.z)); wh.scale.setScalar(s);
  const box2=new THREE.Box3().setFromObject(wh); wh.position.y = -box2.min.y; wh.position.x = carStartX - WAREHOUSE_DISTANCE_BEHIND; wh.position.z = spawnZ; scene.add(wh);
}).catch(()=>console.warn('Could not load warehouse OBJ.'))  ;

/* ===================== Minimap (perf-optimized) ===================== */
const mm = document.getElementById('minimap');
const mmCtx = mm.getContext('2d', { alpha: true });
function resizeMinimap(){ const dpr=Math.min(2, window.devicePixelRatio||1); const cssW=mm.clientWidth, cssH=mm.clientHeight; mm.width=Math.round(cssW*dpr); mm.height=Math.round(cssH*dpr); mmCtx.setTransform(dpr,0,0,dpr,0,0); }
resizeMinimap(); addEventListener('resize', resizeMinimap);
const MINIMAP_SCALE=1.8; const MINIMAP_RADIUS = ()=> Math.min(mm.clientWidth, mm.clientHeight)*0.5;
let mmVisibleSegments=[]; let mmLastFilter=0; const MM_FILTER_HZ=150; const MM_DRAW_HZ=66; let mmLastDraw=0;

function refreshVisibleSegments(){
  const now=performance.now(); if (now - mmLastFilter < MM_FILTER_HZ) return; mmLastFilter = now;
  const Rw=(MINIMAP_RADIUS()/MINIMAP_SCALE)+8; const cx=car.position.x, cz=car.position.z; const L=ROAD_LEN+JOIN_EPS;
  mmVisibleSegments=[];
  for(const s of roadSegments){
    if (Math.abs(s.x - cx) > Rw + L/2) continue;
    if (Math.abs(s.z - cz) > Rw + L/2) continue;
    const dx=s.x-cx, dz=s.z-cz; if ((dx*dx + dz*dz) > (Rw+L/2)*(Rw+L/2)) continue;
    mmVisibleSegments.push(s);
  }
}
function drawMinimap(){
  const now=performance.now(); if (now - mmLastDraw < MM_DRAW_HZ) return; mmLastDraw = now;
  const w=mm.clientWidth, h=mm.clientHeight; const cx=w/2, cz=h/2;
  mmCtx.clearRect(0,0,w,h);
  mmCtx.save(); mmCtx.beginPath(); mmCtx.arc(cx,cz,MINIMAP_RADIUS(),0,Math.PI*2); mmCtx.clip();
  mmCtx.fillStyle='#202326'; mmCtx.fillRect(0,0,w,h);
  const carX=car.position.x, carZ=car.position.z;
  mmCtx.strokeStyle='rgba(210,210,210,0.85)'; mmCtx.lineCap='round'; const roadHalfW=(ROAD_WIDTH*MINIMAP_SCALE)*0.33; mmCtx.lineWidth=Math.max(2,roadHalfW);
  const L=ROAD_LEN+JOIN_EPS;
  for(const s of mmVisibleSegments){
    if(s.isX){ const x1=(s.x - L/2 - carX)*MINIMAP_SCALE + cx; const x2=(s.x + L/2 - carX)*MINIMAP_SCALE + cx; const z=(s.z - carZ)*MINIMAP_SCALE + cz; mmCtx.beginPath(); mmCtx.moveTo(x1,z); mmCtx.lineTo(x2,z); mmCtx.stroke(); }
    else     { const z1=(s.z - L/2 - carZ)*MINIMAP_SCALE + cz; const z2=(s.z + L/2 - carZ)*MINIMAP_SCALE + cz; const x=(s.x - carX)*MINIMAP_SCALE + cx; mmCtx.beginPath(); mmCtx.moveTo(x,z1); mmCtx.lineTo(x,z2); mmCtx.stroke(); }
  }
  mmCtx.save(); mmCtx.beginPath(); mmCtx.arc(cx,cz,7,0,Math.PI*2); mmCtx.fillStyle='#17c964'; mmCtx.shadowColor='rgba(0,0,0,0.45)'; mmCtx.shadowBlur=6; mmCtx.fill(); mmCtx.lineWidth=2; mmCtx.strokeStyle='rgba(0,0,0,0.35)'; mmCtx.stroke(); mmCtx.restore();
  mmCtx.beginPath(); mmCtx.arc(cx,cz,MINIMAP_RADIUS()-1,0,Math.PI*2); mmCtx.strokeStyle='rgba(255,255,255,0.06)'; mmCtx.lineWidth=2; mmCtx.stroke();
  mmCtx.restore();
}

/* ===================== Parcel drop + toast ===================== */
function showToast(message, ms=3000){ const t=document.getElementById('toast'); t.textContent=message; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), ms); }
function dropParcel(){
  const el=document.createElement('div'); el.className='parcel'; document.body.appendChild(el);
  requestAnimationFrame(()=>{ el.style.transform=`translateY(${window.innerHeight+80}px)`; el.style.opacity='0'; });
  el.addEventListener('transitionend', ()=>{ el.remove(); showToast('parcel received, head to the destination', 3000); }, { once:true });
}

/* ===================== Bootstrap flow ===================== */
async function bootstrap(){
  const small = await loadGLB(BLD_PATH, SMALL_GLB);
  if (small) { SMALL_PREFAB=small.root; SMALL_H=small.height; }

  const initialRadius=200;
  for (const s of roadSegments){ const d=Math.hypot(car.position.x - s.x, car.position.z - s.z); if (d<initialRadius && !active.has(segKey(s))) spawnPair(s,true); }

  loadGLB(BLD_PATH, LARGE_GLB).then(res=>{
    if (!res) return; LARGE_PREFAB=res.root; LARGE_H=res.height;
    for (const [,pair] of active) upgradePairIfNeeded(pair);
    streamingEnabled=true;
  }).catch(()=>{ streamingEnabled=true; });
  if (!small) streamingEnabled=true;

  /* Demo: a couple of obstacles ahead + one pursuer behind (remove if not needed) */
  addRoadblockAt(carStartX + ROAD_LEN*1.5, spawnZ, true);
  addRoadblockAt(carStartX + ROAD_LEN*3.0, spawnZ, true);
  spawnPursuer(carStartX - 30, spawnZ);
}
bootstrap();

/* ===================== Controls & movement ===================== */
const keys=new Set();
addEventListener('keydown', e=>{
  if (['KeyW','KeyA','KeyS','KeyD','KeyC','KeyL','KeyN','KeyH','KeyR','KeyP','KeyB','KeyE'].includes(e.code)) e.preventDefault();
  keys.add(e.code);
});
addEventListener('keyup', e=> keys.delete(e.code));

let speed=0; const params={ accel:8.0, brake:12.0, reverseAccel:6.0, maxFwd:14.0, maxRev:6.0, friction:3.5, steerRate:1.8, minSteerFactor:0.35 };
const camTarget=new THREE.Vector3(); const FP_EYE_OFFSET=new THREE.Vector3(0.05,1.55,0.12);

function update(dt){
  if (keys.has('KeyW')) speed += params.accel * dt;
  else if (keys.has('KeyS')) speed += (speed>0 ? -params.brake : -params.reverseAccel) * dt;
  else { const s=Math.sign(speed); speed -= s*params.friction*dt; if (Math.sign(speed)!==s) speed=0; }
  speed = THREE.MathUtils.clamp(speed, -params.maxRev, params.maxFwd);

  let steer=0; if (keys.has('KeyA')) steer += 1; if (keys.has('KeyD')) steer -= 1;
  const steerFactor = THREE.MathUtils.lerp(1.8, params.minSteerFactor, Math.min(Math.abs(speed)/params.maxFwd, 1));
  heading += params.steerRate * steerFactor * steer * dt;

  const forward = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);

  // collision-aware movement
  const moveLen = speed*dt;
  const proposed = car.position.clone().addScaledVector(forward, moveLen);
  const fixed = resolveCarCollisions(proposed);
  const pushedDist = proposed.distanceTo(fixed);
  if (pushedDist > 0.0001 && moveLen > 0) speed = Math.max(0, speed - 8.0*dt);

  car.position.copy(fixed);
  car.rotation.set(0, heading, 0);

  // one-tap actions
  if (keys.has('KeyC')) { firstPerson = !firstPerson; keys.delete('KeyC'); }
  if (keys.has('KeyL')) { setStreetLights(!streetLightsOn); keys.delete('KeyL'); }
  if (keys.has('KeyH')) { setHeadlights(!headlightsOn); keys.delete('KeyH'); }
  if (keys.has('KeyR')) { replacePlaceholdersNear(car.position, 400, false); keys.delete('KeyR'); }
  if (keys.has('KeyP')) { dropParcel(); keys.delete('KeyP'); }
  if (keys.has('KeyB')) { spawnRoadblockAhead(); keys.delete('KeyB'); }
  if (keys.has('KeyE')) { spawnPursuerBehind();  keys.delete('KeyE'); }

  if (keys.has('KeyN')) {
    keys.delete('KeyN');
    const toNight = sun.intensity > 0.3;
    if (toNight) {
      sun.intensity = 0.04; amb.intensity = 0.06; renderer.toneMappingExposure = 1.15; scene.background.set(0x04050a);
      setStreetLights(true); setHeadlights(true);
    } else {
      sun.intensity = 0.8; amb.intensity = 0.45; renderer.toneMappingExposure = 1.0; scene.background.set(0x101018);
      setStreetLights(false); setHeadlights(false);
    }
  }

  updateStreaming(performance.now());

  // keep sun & shadow tight to the car
  sun.position.set(car.position.x + 25, car.position.y + 35, car.position.z + 10);
  const cam = sun.shadow.camera;
  cam.position.set(car.position.x, car.position.y + 20, car.position.z);
  cam.updateProjectionMatrix(); cam.updateMatrixWorld();

  // camera follow
  if (firstPerson) {
    const eye = FP_EYE_OFFSET.clone().applyAxisAngle(new THREE.Vector3(0,1,0), heading).add(car.position);
    camera.position.lerp(eye, 0.25);
    camTarget.copy(eye).addScaledVector(forward, 20); camTarget.y += 0.10; camera.lookAt(camTarget);
  } else {
    const off = new THREE.Vector3(-6.5,3.0,0.0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);
    camera.position.lerp(car.position.clone().add(off), 0.08);
    camTarget.copy(car.position).addScaledVector(forward, 4.0);
    camera.lookAt(camTarget);
  }

  // update car velocity vector for collision math
  carVelVec.copy(forward).multiplyScalar(speed);

  // enemies move
  updateAgents(dt);

  // handle car <-> pursuer collisions + damage
  handleCarAgentCollisions(dt);

  // minimap
  refreshVisibleSegments(); drawMinimap();
}

/* ===================== Minimap helpers & building replacement ===================== */
function isGreyPlaceholder(mesh){
  if (!mesh?.isMesh) return false;
  const g=mesh.geometry; if (!(g && g.isBoxGeometry)) return false;
  const m=mesh.material; if (!m || !m.color) return false;
  const hex=m.color.getHex(); const isGreyish = hex>=0x3a3a3a && hex<=0xa0a0a0;
  return isGreyish && !mesh.userData.__isRealBuilding;
}
function cloneBuildingAt(pos, rotY, targetHeight, preferSmall){
  const clone = makeBuildingClone(targetHeight, preferSmall); clone.position.copy(pos); clone.rotation.y = rotY||0;
  clone.traverse(o=>{ if (o.isMesh) o.userData.__isRealBuilding = true; });
  clone.updateWorldMatrix(true,true);
  clone.userData.aabb = makeAABBFor(clone);
  scene.add(clone); return clone;
}
function replacePlaceholdersNear(center=car.position, radius=160, preferSmall=false){
  const toReplace=[]; scene.traverse(obj=>{ if (obj.isMesh && isGreyPlaceholder(obj)){ const d=obj.position.distanceTo(center); if (d<=radius) toReplace.push(obj); } });
  for (const box of toReplace){
    const b=new THREE.Box3().setFromObject(box); const size=new THREE.Vector3(); b.getSize(size);
    const height=Math.max(6,size.y); cloneBuildingAt(box.position, box.rotation?.y||0, height, preferSmall);
    box.parent?.remove(box);
  }
}

/* ===================== Tick + adaptive resolution ===================== */
let last=performance.now(), dynDPR=START_DPR; const DPR_MIN=0.8, DPR_MAX=Math.min(2, START_DPR);
let fpsMeasureT=0, fpsFrames=0;
function tick(now=performance.now()){
  const dt=Math.min(0.033, (now-last)/1000); last=now;
  update(dt); renderer.render(scene, camera);
  fpsFrames++; if(!fpsMeasureT) fpsMeasureT=now; const elapsed=now-fpsMeasureT;
  if (elapsed>500){ const fps=(fpsFrames*1000)/elapsed; fpsFrames=0; fpsMeasureT=now;
    if (fps<45 && dynDPR>DPR_MIN){ dynDPR=Math.max(DPR_MIN, dynDPR-0.1); renderer.setPixelRatio(dynDPR); }
    else if (fps>58 && dynDPR<DPR_MAX){ dynDPR=Math.min(DPR_MAX, dynDPR+0.1); renderer.setPixelRatio(dynDPR); }
  }
  requestAnimationFrame(tick);
}
tick();

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight); renderer.setPixelRatio(dynDPR);
  resizeMinimap();
});
</script>
</body>
</html>
