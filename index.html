<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Extraction • City Run</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#111; overflow:hidden; }

    /* ===== HUD (hidden until Play) ===== */
    #info { position:absolute; top:10px; left:10px; color:#eee; font:14px/1.3 system-ui, sans-serif; z-index:7; display:none; }
    #minimap {
      position: absolute; left: 12px; bottom: 12px; width: 210px; height: 210px;
      border-radius: 50%; background: #1c1e22;
      box-shadow: 0 2px 8px rgba(0,0,0,0.45), inset 0 0 0 2px rgba(255,255,255,0.05);
      z-index: 6; display:none;
    }
    #healthUI {
      position: absolute; top: 12px; right: 12px; width: 240px; height: 18px; z-index: 8;
      font: 12px/1 system-ui, sans-serif; color: #cfd6dc; text-shadow: 0 1px 2px rgba(0,0,0,.6); display:none;
    }
    #healthLabel { margin-bottom: 6px; opacity: .9; }
    #healthBar {
      position: relative; width: 100%; height: 12px; background: rgba(255,255,255,0.08);
      border-radius: 10px; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.07), 0 2px 6px rgba(0,0,0,.3); overflow: hidden;
    }
    #healthFill {
      position: absolute; left: 0; top: 0; height: 100%; width: 100%;
      background: hsl(120, 78%, 45%); border-radius: inherit;
      transition: width .15s ease, background-color .15s ease, filter .15s ease;
      filter: drop-shadow(0 0 4px rgba(0,0,0,.35));
    }
    .hp-damage #healthFill { filter: brightness(1.2) saturate(1.2); }

    /* Parcel + toast UI */
    .parcel {
      position: fixed; width: 28px; height: 28px; background: #8b5a2b; border: 2px solid #4e341a; border-radius: 4px;
      box-shadow: 0 6px 12px rgba(0,0,0,.4); top: -40px; left: calc(50% - 14px);
      opacity: 1; transform: translateY(0);
      transition: transform 1.4s cubic-bezier(.2,.7,.2,1), opacity 1.4s linear; z-index: 9999;
    }
    #toast {
      position: fixed; top: 14%; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.75); color: #fff; padding: 10px 14px; border-radius: 10px;
      font: 600 18px/1.3 system-ui, sans-serif; letter-spacing: .2px;
      box-shadow: 0 6px 18px rgba(0,0,0,.35); opacity: 0; pointer-events: none;
      transition: opacity .25s ease; z-index: 10000;
    }
    #toast.show { opacity: 1; }

    /* ===== Start Screen Overlay ===== */
    #start-screen {
      position: fixed; inset: 0; display: grid; place-items: center; z-index: 10001;
      background: radial-gradient(1200px 600px at 50% 0%, #1b1b24 0%, #0d0d12 55%, #07070a 100%);
    }
    .menu-card {
      width: min(680px, 92vw); padding: 32px 28px 28px; border-radius: 18px;
      background: linear-gradient(180deg, #15151d 0%, #0f0f16 100%);
      box-shadow: 0 35px 80px #000a, inset 0 1px 0 #ffffff0e, inset 0 0 0 1px #ffffff14;
      text-align: center; color: #e9ebff;
    }
    .title {
      margin: 0 0 18px; font: 800 64px/0.95 'Segoe UI', system-ui, -apple-system, sans-serif;
      letter-spacing: .06em; text-shadow: 0 12px 40px #0008, 0 0 18px #7cf1ff26;
    }
    .menu { display: flex; flex-direction: column; gap: 14px; align-items: center; margin-top: 8px; }
    .btn {
      width: min(440px, 85vw); padding: 14px 18px; border-radius: 12px; border: none; cursor: pointer;
      font: 700 18px/1 system-ui, sans-serif; letter-spacing: .02em;
      background: #1f8fff; color: #fff;
      box-shadow: 0 12px 24px #0b377c55, inset 0 0 0 1px #ffffff22;
      transition: transform .08s ease, filter .08s ease, background .2s ease;
    }
    .btn:hover { transform: translateY(-1px); filter: brightness(1.06); }
    .btn.secondary { background: #2a2a36; color: #dfe2ff; box-shadow: inset 0 0 0 1px #ffffff22; }
    .btn.tertiary  { background: #22222c; color: #cfd2f5; box-shadow: inset 0 0 0 1px #ffffff22; }
    .kbd { display:inline-block; padding:2px 6px; border-radius:6px; margin:0 2px; background:#00000066; color:#eaeaff; font:12px/1.4 monospace; border:1px solid #ffffff22; }

    /* Modal */
    #modal { position: fixed; inset: 0; display: none; place-items: center; z-index: 10002; background: linear-gradient(#0006,#000a); }
    .modal-card {
      width: min(820px, 92vw); max-height: min(80vh, 700px); overflow: auto; padding: 20px 22px;
      border-radius: 16px; background: #14141c; color: #e9ebff; box-shadow: 0 20px 80px #000c;
    }
    .modal-card h2 { margin: 6px 0 10px; font: 700 28px/1.1 system-ui, sans-serif; }
    .modal-actions { display:flex; justify-content:flex-end; margin-top:10px; }
    .close { padding:10px 14px; background:#2a2a36; color:#e9ebff; border:none; border-radius:10px; cursor:pointer; }

    /* Vehicle segmented buttons */
.seg { display:flex; gap:8px; flex-wrap:wrap; }
.segbtn {
  padding:10px 12px; border-radius:10px; border:1px solid #2c3442;
  background:#141b25; color:#dfe6ef; cursor:pointer;
  font:600 14px/1 system-ui; letter-spacing:.01em;
  box-shadow: inset 0 0 0 1px #ffffff12;
  transition: transform .08s ease, filter .08s ease, background .15s ease;
}
.segbtn:hover { transform: translateY(-1px); filter: brightness(1.06); }
.segbtn.active {
  background:#1f8fff; color:#fff;
  box-shadow: 0 10px 20px #0b377c44, inset 0 0 0 1px #ffffff22;
}

  </style>

  <!-- Import map -->
  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
  } }
  </script>
</head>
<body>
<!-- ===== Start Screen ===== -->
<div id="start-screen" aria-modal="true" role="dialog">
  <div class="menu-card" role="document">
    <h1 class="title">Extraction</h1>
    <p style="margin:0 0 18px; color:#adb0c7;">A fast-paced delivery run. Avoid obstacles, outsmart pursuers, and make it in time.</p>
    <div class="menu">
      <button id="btn-play" class="btn" autofocus>Play</button>
      <button id="btn-instructions" class="btn secondary">Instructions &amp; Controls</button>
      <button id="btn-credits" class="btn tertiary">Credits</button>
      <button id="btn-youtube" class="btn secondary">YouTube videos (trailer + dev log)</button>
    </div>
    <p style="margin:16px 0 0; color:#9aa0b5;">
      Tip: <span class="kbd">WASD</span> to drive • <span class="kbd">C</span> camera • <span class="kbd">N</span> day/night •
      <span class="kbd">H</span> headlights 
    </p>
  </div>
</div>

<!-- ===== Level Select ===== -->
<div id="levelSelect" style="position:absolute; inset:0; display:none; z-index:12;
  background:rgba(0,0,0,.65); align-items:center; justify-content:center;">
  <div style="background:#11151b; border:1px solid #2a3038; border-radius:12px;
      width:min(520px,92vw); padding:20px 22px; box-shadow:0 18px 46px rgba(0,0,0,.5);">
    <div style="color:#e9eef5; font:700 20px/1.2 system-ui, sans-serif; margin:0 0 10px;">
      Select Level
    </div>

    <div style="display:grid; gap:10px;">
      <button id="lvlBtn0" style="padding:14px 16px; min-height:64px; border-radius:10px; border:1px solid #2c3442;
  background:#1a2230; color:#e4edf6; font:600 14px system-ui; cursor:pointer;
  text-align:center; line-height:1.2;"></button>

<button id="lvlBtn1" style="padding:14px 16px; min-height:64px; border-radius:10px; border:1px solid #2c3442;
  background:#1a2230; color:#e4edf6; font:600 14px system-ui; cursor:pointer;
  text-align:center; line-height:1.2;"></button>

<button id="lvlBtn2" style="padding:14px 16px; min-height:64px; border-radius:10px; border:1px solid #2c3442;
  background:#1a2230; color:#e4edf6; font:600 14px system-ui; cursor:pointer;
  text-align:center; line-height:1.2;"></button>

<button id="lvlBtn3" style="padding:14px 16px; min-height:64px; border-radius:10px; border:1px solid #2c3442;
  background:#1a2230; color:#e4edf6; font:600 14px system-ui; cursor:pointer;
  text-align:center; line-height:1.2;"></button>

      <!-- VEHICLE SELECT (new) -->
    <hr style="border:none; border-top:1px solid #202732; margin:14px 0;">
    <div id="vehicleSelectWrap" style="margin-top:6px;">
      <div style="color:#cfd6dc; font:700 14px/1.2 system-ui, sans-serif; margin:0 0 8px;">
        Select Vehicle
      </div>
      <div class="seg">
        <button class="segbtn" data-vehicle="Truck" id="vehTruck">Truck</button>
        <button class="segbtn" data-vehicle="Sport" id="vehSport">Sport</button>
        <button class="segbtn" data-vehicle="Bike"  id="vehBike">Something Silly</button>
      </div>
      <div id="vehicleHint" style="margin-top:8px; color:#9aa6b2; font:12px/1.35 system-ui;">
        (Only selection is saved for now; visual change comes later.)
      </div>
    </div>



    </div>

    <div style="display:flex; justify-content:space-between; align-items:center; margin-top:12px;">
      <button id="btnBackStart" style="padding:8px 12px; border-radius:8px; border:1px solid #2c3442;
        background:#141b25; color:#b8c3cf; font:600 13px system-ui; cursor:pointer;">
        ← Back
      </button>
      <div style="font:12px/1.2 system-ui; color:#9aa6b2;">Keyboard + mouse required</div>
    </div>
  </div>
</div>

<!-- ===== Credits Screen ===== -->
<div id="creditsScreen" style="position:absolute; inset:0; display:none; z-index:12;
  background:rgba(0,0,0,.65); align-items:center; justify-content:center;">
  <div style="background:#11151b; border:1px solid #2a3038; border-radius:12px;
      width:min(620px,92vw); padding:22px 22px; box-shadow:0 18px 46px rgba(0,0,0,.5);">
    <div style="color:#e9eef5; font:800 22px/1.2 system-ui, sans-serif; margin:0 0 4px;">
      Credits
    </div>
    <div style="color:#9aa6b2; font:500 13px/1.4 system-ui; margin:0 0 14px;">
      Thanks to the following creators and libraries:
    </div>

    <div id="creditsList" style="display:grid; gap:10px;"></div>

    <div style="display:flex; justify-content:space-between; align-items:center; margin-top:14px;">
      <button id="btnBackFromCredits" style="padding:8px 12px; border-radius:8px; border:1px solid #2c3442;
        background:#141b25; color:#b8c3cf; font:600 13px system-ui; cursor:pointer;">
        ← Back
      </button>
      <div style="font:12px/1.2 system-ui; color:#9aa6b2;">
        UI inspired by the Level Select layout
      </div>
    </div>
  </div>
</div>



<!-- ===== Game Over / Failure ===== -->
<div id="failUI" style="position:absolute; inset:0; display:none; z-index:20;
  background:rgba(0,0,0,.6); align-items:center; justify-content:center;">
  <div style="background:#11151b; border:1px solid #2a3038; border-radius:12px;
      width:min(520px,92vw); padding:20px 22px; box-shadow:0 18px 46px rgba(0,0,0,.5);">
    <div id="failTitle" style="color:#ffb3b3; font:800 20px/1.2 system-ui, sans-serif;">
      Mission Failed
    </div>
    <div id="failMsg" style="color:#cfd6dc; margin:8px 0 14px; font:500 14px/1.35 system-ui;">
      Time’s up!
    </div>

    <div style="display:flex; gap:10px;">
      <button id="btnRetry" style="padding:10px 14px; border-radius:10px; border:1px solid #2c3442;
        background:#1a2230; color:#e4edf6; font:600 14px system-ui; cursor:pointer;">
        Retry
      </button>
      <button id="btnBackLevels" style="padding:10px 14px; border-radius:10px; border:1px solid #2c3442;
        background:#141b25; color:#b8c3cf; font:600 14px system-ui; cursor:pointer;">
        Back to Level Select
      </button>
    </div>
  </div>
</div>

<!-- ===== Mission Success (make sure this is a SIBLING of #failUI, not inside it) ===== -->
<div id="successUI" style="position:absolute; inset:0; display:none; z-index:20;
  background:rgba(0,0,0,.6); align-items:center; justify-content:center;">
  <div style="background:#11151b; border:1px solid #2a3038; border-radius:12px;
      width:min(520px,92vw); padding:20px 22px; box-shadow:0 18px 46px rgba(0,0,0,.5);">
    <div id="successTitle" style="color:#bfffd3; font:800 20px/1.2 system-ui, sans-serif;">
      Mission Successfully Completed
    </div>
    <div id="successMsg" style="color:#cfd6dc; margin:8px 0 14px; font:500 14px/1.35 system-ui;">
      Great driving! Ready for the next run?
    </div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <button id="btnNextLevel" style="padding:10px 14px; border-radius:10px; border:1px solid #2c3442;
        background:#1a2230; color:#e4edf6; font:600 14px system-ui; cursor:pointer;">
        Continue to Next Level
      </button>
      <button id="btnBackHome" style="padding:10px 14px; border-radius:10px; border:1px solid #2c3442;
        background:#141b25; color:#b8c3cf; font:600 14px system-ui; cursor:pointer;">
        Back to Home Screen
      </button>
    </div>
  </div>
</div>




    




<!-- Modal -->
<div id="modal">
  <div class="modal-card" role="dialog" aria-labelledby="modal-title">
    <h2 id="modal-title">Instructions</h2>
    <div id="modal-content"></div>
    <div class="modal-actions"><button id="btn-close" class="close">Close</button></div>
  </div>
</div>

<div id="info">
  W/S = forward/back • A/D = steer • C = toggle 1st/3rd • N = day/night • H = headlights • Z = reverse view • Hold RMB = rotate camera
 
</div>

<!-- Health HUD -->
<div id="healthUI">
  <div id="healthLabel">Health</div>
  <div id="healthBar"><div id="healthFill"></div></div>
</div>

<!-- Objective HUD -->
<div id="objectiveUI" style="position:absolute; top:36px; right:12px; z-index:8; display:none; color:#cfd6dc; font:600 14px/1.2 system-ui, sans-serif;">
  <div id="hudLevel" style="opacity:.95; margin-bottom:6px;"></div>
  <div style="display:flex; gap:12px;">
    <div>⏱ <span id="hudTimer">00:00</span></div>
    <div>📦 <span id="hudGoals">0/0</span></div>
  </div>
</div>


<canvas id="minimap"></canvas>
<div id="toast" aria-live="polite"></div>

<canvas id="minimap"></canvas>

<!-- ===== Pause Menu Overlay ===== -->
<div id="pauseMenu" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0, 0, 0, 0.8);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 9999;
">
  <h1 style="color: white; font-size: 2em; margin-bottom: 1em;">Paused</h1>

  <!-- ▼▼ NEW: Music Volume control ▼▼ -->
  <div style="display:flex; flex-direction:column; gap:8px; align-items:center; margin-bottom: 16px;">
    <label for="musicVolume" style="color:#e9ebff; font:600 14px/1.2 system-ui;">
      Music Volume: <span id="musicVolumeValue">25%</span>
    </label>
    <input
      id="musicVolume"
      type="range"
      min="0" max="1" step="0.01"
      value="0.25"
      style="width:min(360px, 80vw); accent-color:#1f8fff; cursor:pointer;"
      aria-label="Music Volume"
    />
  </div>
  <!-- ▲▲ NEW: Music Volume control ▲▲ -->

  <button id="btnQuitLevel" style="padding: 12px 24px; margin: 8px; font-size: 1.1em;">Quit Level</button>
  <button id="btnInstructions" style="padding: 12px 24px; margin: 8px; font-size: 1.1em;">Instructions and Controls</button>
</div>


<div id="toast" aria-live="polite"></div>

<!-- Confetti (no download needed) -->
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>


<script type="module">
import * as THREE from 'three';
import { OBJLoader }  from 'three/addons/loaders/OBJLoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';







/* -------------------- Asset paths -------------------- */
const WH_PATH = 'assets/50-ware-house/';
const WH_OBJ  = 'ware house.obj';

/* Vehicles */
const VEHICLE_PATH = 'assets/';
const TRUCK_GLB    = 'Pickup Truck.glb';
// NEW: other vehicle files
const SPORT_GLB = 'CAR Model.glb';
const BIKE_GLB  = 'cartoon banana car.glb';

// NEW: map a selection to its GLB
const VEHICLE_FILES = {
  Truck: TRUCK_GLB,
  Sport: SPORT_GLB,
  Bike:  BIKE_GLB
};


/* Pursuer: Anti-gravity drone (replaces police car) */
const DRONE_CANDIDATES = [
  'Anti-Gravity Drone.glb',
  'Antigravity Drone.glb',
  'Drone.glb',
  'anti_gravity_drone.glb'
];

/* Buildings */
const BLD_PATH  = 'assets/';
const LARGE_GLB = 'Large Building.glb';
const SMALL_GLB = 'Small Building.glb';

/* Obstacles (roadblocks → rubbish model) */
const RUBBISH_GLB = 'Rubbish.glb';

/* Slowdown hazard (smashed glass) */
const GLASS_GLB = 'Smashed Glass.glb';

/* Power-up box (yellow question block) */
const POWER_BOX_GLB = '-Block.glb';


/* Street light model */
const STREET_LIGHT_GLB = 'Street Light.glb';
/* ---- Street-light tuning ---- */
const STREET_LIGHT_TARGET_H = 9.5;   // meters tall (was ~5.5)
const STREET_LIGHT_YAW_CORR  = -Math.PI;     // if the lamp's arm points the “wrong way”, try Math.PI/2 or -Math.PI/2
const STREET_LIGHT_OVERHANG  = 0.9;   // meters to push the lamp along its arm toward road center (use negative to go the other way)

/* ---- GLB street-light lighting ---- */
const GLB_LAMP_ON_INTENSITY  = 8.0;   // night brightness
const GLB_LAMP_OFF_INTENSITY = 0.0;   // day (off)
const GLB_LAMP_RANGE         = 25;    // how far it lights the road
const GLB_LAMP_DECAY         = 1.5;     // physically-based falloff
const GLB_LAMP_LOCAL_FORWARD = 0.70;  // extra push toward the road from the pole (meters)
const GLB_LAMP_LOCAL_DOWN    = 0.15;  // hang a little below the head (meters)
const GLB_LAMP_BULB_DROP   = 0.80;  // how far the bulb hangs below the head (↑ to lower only the bulb)
const GLB_LAMP_TARGET_DROP = 3.2;   // how far the light aims downward (↑ to aim lower)



/* Goal flag */
const GOAL_FLAG_GLB = 'Goal Flag.glb';

/* Paver (ground) */
const PAVER_GLB = 'flagstone paver.glb';

/* Rescue target (person to reach) */
const RESCUE_GLB = 'Woman.glb';


// === Background Music Setup ===
const bgMusic = new Audio('assets/sounds/background-music.mp3');
bgMusic.loop = true;
bgMusic.volume = 0.25; // softer than engine sounds

// Attempt autoplay (some browsers need user click first)
bgMusic.play().catch(() => {
  console.log('Background music will start after user interaction.');
});

// Start the music when user clicks anywhere (fallback for autoplay restriction)
document.addEventListener('click', () => {
  if (bgMusic.paused) bgMusic.play();
}, { once: true });








// Keep references so we can turn them on/off with N
let glbStreetLights = [];




/* ----------------------------------------------------- */

/* ===== Start screen wiring ===== */
const startEl   = document.getElementById('start-screen');
const modalEl   = document.getElementById('modal');
const btnPlay   = document.getElementById('btn-play');
const btnInstr  = document.getElementById('btn-instructions');
const btnCreds  = document.getElementById('btn-credits');
const btnClose  = document.getElementById('btn-close');
const modalTitle   = document.getElementById('modal-title');
const modalContent = document.getElementById('modal-content');
const btnYoutube = document.getElementById('btn-youtube');


// === Music volume slider (Pause Menu) ===
const musicVolSlider = document.getElementById('musicVolume');
const musicVolLabel  = document.getElementById('musicVolumeValue');

// Load saved volume if present
const savedMusicVol = parseFloat(localStorage.getItem('musicVolume'));
if (!Number.isNaN(savedMusicVol)) {
  bgMusic.volume = Math.min(1, Math.max(0, savedMusicVol));
}

// Reflect current bgMusic volume in the UI
if (musicVolSlider && musicVolLabel) {
  musicVolSlider.value = String(bgMusic.volume.toFixed(2));
  musicVolLabel.textContent = `${Math.round(bgMusic.volume * 100)}%`;

  // Live update volume as the user drags
  musicVolSlider.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    bgMusic.volume = Math.min(1, Math.max(0, v));
    musicVolLabel.textContent = `${Math.round(bgMusic.volume * 100)}%`;
    localStorage.setItem('musicVolume', bgMusic.volume.toFixed(2));
  });
}


// Level select UI
const levelSelectEl = document.getElementById('levelSelect');
const btnLvl0 = document.getElementById('lvlBtn0');
const btnLvl1 = document.getElementById('lvlBtn1');
const btnLvl2 = document.getElementById('lvlBtn2');
const btnLvl3 = document.getElementById('lvlBtn3');

// --- Vehicle selection UI (new) ---
const vehButtons = Array.from(document.querySelectorAll('.segbtn[data-vehicle]'));

// Persist choice between visits (optional)
let selectedVehicle = localStorage.getItem('vehicle') || 'Truck';

function updateVehicleUI() {
  vehButtons.forEach(b => b.classList.toggle('active', b.dataset.vehicle === selectedVehicle));
}

vehButtons.forEach(b => {
  b.addEventListener('click', () => {
    selectedVehicle = b.dataset.vehicle;
    localStorage.setItem('vehicle', selectedVehicle);
    updateVehicleUI();
    // optional little feedback
    showToast(`Selected: ${selectedVehicle}`, 900);
  });
});


const btnBackStart = document.getElementById('btnBackStart');

// Failure UI
const failUI = document.getElementById('failUI');
const failMsgEl = document.getElementById('failMsg');
const btnRetry = document.getElementById('btnRetry');
const btnBackLevels = document.getElementById('btnBackLevels');


// Keep labels synced with LEVELS[]
function refreshLevelSelectLabels(){
  // No window.LEVELS guard — module scope variables aren't on window
 const desc = [
  '3 goals, 3:00 timer, no pursuers, day.',
  '4 goals, 2:30, 1 pursuer, night + lamps on.',
  '5 goals, 2:30, 2–3 pursuers, extra roadblocks.',
  'Find your girlfriend Petra Stephanie — 1 target, 2:30, 3 pursuers .'
];


  const setBtn = (btn, idx) => {
    const L = LEVELS[idx]; // direct reference; LEVELS is in the same module
    btn.innerHTML =
      `<div style="font-weight:700; color:#e9eef5;">Level ${idx+1} — ${L.name}</div>
       <div style="font-weight:500; font-size:12px; color:#b9c4d0; opacity:.92; margin-top:2px;">
         ${desc[idx]}
       </div>`;
  };

  setBtn(btnLvl0, 0);
  setBtn(btnLvl1, 1);
  setBtn(btnLvl2, 2);
  setBtn(btnLvl3, 3);

}




const infoEl     = document.getElementById('info');
const healthWrap = document.getElementById('healthUI');
const minimapEl  = document.getElementById('minimap');

let gameStarted = false;
function openModal(title, html){ modalTitle.textContent = title; modalContent.innerHTML = html; modalEl.style.display = 'grid'; }
function closeModal(){ modalEl.style.display = 'none'; }
/* ===== Credits data ===== */
const CREDITS = [
  // Objects & textures
  { title: "Small Building by Kenney", url: "https://poly.pizza/m/QjL4Fo9dU9", note: "" },
  { title: "Large Building by Kenney", url: "https://poly.pizza/m/yKo7F36Qk2", note: "" },
  { title: "Pickup Truck by Quaternius", url: "https://poly.pizza/m/qn4grQgHm8", note: "" },
  { title: "Anti-Gravity Drone by Adam Marc Williams", url: "https://poly.pizza/m/fiYuC73Xlwp", note: "CC-BY 3.0 · via Poly Pizza" },
  { title: "Smashed Glass by AlexCrean", url: "https://poly.pizza/m/s5z0Wvs1Wi", note: "CC-BY 3.0 · via Poly Pizza" },
  { title: "Rubbish by Poly by Google", url: "https://poly.pizza/m/fxU6_KtzTiX", note: "CC-BY 3.0 · via Poly Pizza" },
  { title: "Goal Flag by Quaternius", url: "https://poly.pizza/m/onAi7dx56P", note: "" },
  { title: "?-Block by Studio Creality", url: "https://poly.pizza/m/dIC3dNIL84K", note: "CC-BY 3.0 · via Poly Pizza" },
  { title: "Concrete pavement texture", url: "https://polyhaven.com/a/concrete_pavement", note: "" },

  // Sound effects & music
  { title: "Car engine (loop)", url: "https://freesound.org/people/Dmitry_mansurev64/sounds/748027/", note: "" },
  { title: "Car engine start", url: "https://freesound.org/people/Grasopt/sounds/479351/", note: "" },
  { title: "Drone explosion", url: "https://freesound.org/people/modusmogulus/sounds/792520/", note: "" },
  { title: "Background music", url: "https://freesound.org/people/DominikBraun/sounds/483502/", note: "" },
  { title: "Success sound", url: "https://freesound.org/people/Unlistenable/sounds/391540/", note: "" },

  // Libraries
  { title: "three.js (WebGL library)", url: "https://threejs.org/", note: "" }
];

// ===== Full Instructions / Lore HTML =====
const INSTRUCTIONS_HTML = `
<h2> Game Background – “Extraction”</h2>
<p>
Your closest friend, <strong>Pieter Steph</strong>, has been <strong>kidnapped by the Italian Mafia</strong>. With no ransom money and no leads, you turn to the underworld for help. A shadowy smuggling syndicate agrees to aid your search — but not for free.<br><br>
To earn their trust, you must complete a series of high-risk <strong>delivery missions</strong> across a sprawling, crime-ridden city. The cargo you carry is fragile and highly illegal. Any delay or damage could cost you your only chance to save your friend.<br><br>
Complete all assignments and survive the gauntlet, and the syndicate will finally reveal <strong>Pieter Steph’s last known location</strong>.
</p>

<hr>

<h2> How to Play</h2>
<ul>
  <li><strong>Objective:</strong> Complete all deliveries before the timer runs out. Each successful delivery earns time and progress toward uncovering Pieter Steph’s whereabouts.</li>
  <li><strong>Controls:</strong> Drive your truck through the city streets, following the road network to reach the delivery goal (marked with a bright beacon). Completing a delivery adds <strong>+30 seconds</strong> to your remaining time.</li>
  <li><strong>Avoid Damage:</strong> Crashing into buildings, streetlights, and obstacles slows you down and risks losing control of your vehicle.</li>
  <li><strong>Hazards – Broken Glass:</strong> Scattered across the city are patches of broken glass. Driving over them temporarily <strong>slows your vehicle</strong> and reduces handling precision — leaving you exposed to enemy drones.</li>
  <li><strong>Power-Ups – Yellow Cube:</strong> The yellow cube is a mysterious experimental object left by the syndicate. Collecting it triggers one of two effects:
    <ul>
      <li><em>Reversed Controls:</em> Steering briefly inverts, making handling unpredictable.</li>
      <li><em>Ghost Mode:</em> Your truck temporarily <strong>phases through obstacles</strong> and street debris — a short, powerful escape window.</li>
    </ul>
    Use these effects wisely; both can change the course of a chase.
  </li>
  <li><strong>Enemy Drones:</strong> Patrol drones relentlessly track your position. They can <strong>phase through obstacles</strong> to maintain pursuit, and any collision destroys your truck.</li>
  <li><strong>Timer:</strong> If time reaches zero, the mission fails. Each successful delivery extends your time, but every crash or delay risks failure.</li>
  <li><strong>Night Mode:</strong> Press <kbd>N</kbd> to toggle night lighting. Use headlights to navigate low-visibility areas.</li>
  <li><strong>Mini-Map:</strong> The minimap in the lower-left shows your position, the blue delivery route, and approaching drones.</li>
  <li><strong>Goal:</strong> Complete all deliveries in each level without being destroyed. After the <strong>third level</strong>, the gang will reveal Petra Stephanie’s location.</li>
</ul>

<hr>

<h2> Level Descriptions</h2>

<h3>Level 1 – The Initiation</h3>
<p>
A quiet industrial district with open roads. Drones are few and slow. Learn the layout, get comfortable with handling, and make your first deliveries on time.
</p>

<h3>Level 2 – Urban Pressure</h3>
<p>
Busier city center with tighter turns, more debris, and faster drones. Traffic barriers demand precision driving. Every second counts.
</p>

<h3>Level 3 – The Gauntlet</h3>
<p>
A high-security zone with coordinated drone pursuit and narrower streets. Complete these missions to uncover <strong>Petra Stephanie’s location</strong> and the truth behind his disappearance.
</p>

<h3>Level 4 – The Rescue</h3>
<p>
The ultimate mission where you are given one chance to save Petra Stephanie , but beware as the drone now know your every move
</p>
`;


// === YouTube links (edit the hrefs later with your real URLs) ===
const YOUTUBE_HTML = `
  <h2>Videos</h2>
  <p>Trailer and developer log for <em>Extraction</em>. These open in a new tab.</p>
  <ul style="list-style: none; padding: 0; margin: 14px 0;">
    <li style="margin: 8px 0;">
      <a id="ytTrailer" href="https://youtu.be/VOEjXdywH4s" target="_blank" rel="noopener"
         style="color:#6ab0ff; text-decoration:none;">
        ▶ Trailer
      </a>
    </li>
    <li style="margin: 8px 0;">
      <a id="ytDevlog" href="https://youtu.be/VOEjXdywH4s" target="_blank" rel="noopener"
         style="color:#ff8a8a; text-decoration:none;">
        ▶ Dev log
      </a>
    </li>
  </ul>
  <p style="color:#9aa6b2; font-size:12px; margin-top:16px;">
  </p>
`;






btnInstr.addEventListener('click', ()=>{
  openModal('Instructions & Controls', INSTRUCTIONS_HTML);
});

btnCreds.addEventListener('click', () => {
  // Build rows
  let rows = CREDITS.map((item) => {
    // Remove leading http:// or https:// for display only
    const clean = item.url.replace(/^https?:\/\//, '');

    return '' +
      '<a href="' + item.url + '" target="_blank" rel="noopener" ' +
      '   style="display:block; padding:14px 16px; min-height:64px;' +
      '          border-radius:10px; border:1px solid #2c3442;' +
      '          background:#1a2230; color:#e4edf6; text-decoration:none;' +
      '          font:600 14px system-ui;">' +
      '  <div style="font-weight:800; color:#e9eef5;">' + item.title + '</div>' +
      '  <div style="font-weight:500; font-size:12px; color:#b9c4d0; opacity:.92; margin-top:2px;">' +
           (item.note ? item.note + ' · ' : '') + clean +
      '  </div>' +
      '</a>';
  }).join('');

  const listHtml =
    '<div style="display:grid; gap:10px;">' +
      rows +
    '</div>';

  // Uses your existing modal
  openModal('Credits', listHtml);
});


btnClose.addEventListener('click', closeModal);
modalEl.addEventListener('click', (e)=>{ if (e.target === modalEl) closeModal(); });

// make it async
async function startSelectedLevel(idx){
  // Hide menus, show HUDs
  levelSelectEl.style.display = 'none';
  startEl.style.display = 'none';
  infoEl.style.display = 'block';
  healthWrap.style.display = 'block';
  minimapEl.style.display = 'block';
  objectiveUI.style.display = 'block';

  // 🔄 Ensure the chosen model is attached (Truck / Sport / Bike)
  await ensureVehicle(selectedVehicle);   // <-- add this line

  // Optional feedback (keep if you like)
  console.log('Vehicle selected:', selectedVehicle);
  showToast(`Vehicle: ${selectedVehicle}`, 1200);
  // ⤵ Ensure the canvas gets a real size now that it's visible
  resizeMinimap();
  // draw immediately (skip throttles on first frame)
  mmLastFilter = 0;
  mmLastDraw   = 0;

 // ===== Engine Start Sound + Loop Setup =====
const startSound = new Audio('assets/sounds/car-engine-starting.wav');
startSound.volume = 0.6; // adjust loudness
startSound.play();

// After startup sound ends, start looping engine
startSound.addEventListener('ended', () => {
  if (!window.engineSound) {
    window.engineSound = new Audio('assets/sounds/engine-loop.ogg');
    engineSound.loop = true;
    engineSound.volume = 0.35; // adjust to your liking
  }
  engineSound.currentTime = 0;
  engineSound.play();
});



  // Begin gameplay
  gameStarted = true;
  startLevel(idx);
  // Power-box streaming: start measuring from the current car position
resetPowerBoxProgress();

}

// Hook up buttons
btnLvl0.onclick = () => startSelectedLevel(0);
btnLvl1.onclick = () => startSelectedLevel(1);
btnLvl2.onclick = () => startSelectedLevel(2);
btnLvl3.onclick = () => startSelectedLevel(3);
btnBackStart.onclick = () => {
  levelSelectEl.style.display = 'none';
  startEl.style.display = 'grid'; // your #start-screen uses display:grid
};

// === Global button click sound ===
document.querySelectorAll('button').forEach(btn => {
  btn.addEventListener('click', () => {
    playButtonClickSfx();
  });
});



// Optional: Esc closes selector back to start (only when not in-game)
addEventListener('keydown', (e)=>{
  if (!gameStarted && levelSelectEl.style.display !== 'none' && e.code === 'Escape'){
    levelSelectEl.style.display = 'none';
    startEl.style.display = 'grid';
  }
});

function showFailMenu(msg){
  paused = true;                  // freeze game
  speed = 0;
  keys.clear();                   // stop any held inputs
  failMsgEl.textContent = msg || 'Mission failed.';
  failUI.style.display = 'flex';
}
function hideFailMenu(){ failUI.style.display = 'none'; }

function goToLevelSelect(){
  hideFailMenu();
  gameStarted = false;
  paused = false;

  // Hide HUDs
  infoEl.style.display = 'none';
  healthWrap.style.display = 'none';
  minimapEl.style.display = 'none';
  objectiveUI.style.display = 'none';

  // Show level selector
  refreshLevelSelectLabels();
  levelSelectEl.style.display = 'flex';
  updateVehicleUI(); // NEW: highlight current vehicle choice

}

btnRetry.onclick = () => {
  hideFailMenu();
  paused = false;
  gameStarted = true;
  startLevel(levelIndex);        // retry same level
};
btnBackLevels.onclick = goToLevelSelect;

// Optional keys on fail screen
addEventListener('keydown', (e)=>{
  if (failUI.style.display !== 'none'){
    if (e.code === 'Enter') btnRetry.click();
    if (e.code === 'Escape') btnBackLevels.click();
  }
});

// Success UI
const successUI     = document.getElementById('successUI');
const successTitle  = document.getElementById('successTitle');
const successMsg    = document.getElementById('successMsg');
const btnNextLevel  = document.getElementById('btnNextLevel');
const btnBackHome   = document.getElementById('btnBackHome');

function showSuccessMenu(titleText = 'Mission Successfully Completed', msgText = 'Great driving! Ready for the next run?'){
  paused = true; isPaused = true; speed = 0; keys.clear();
  successTitle.textContent = titleText;
  successMsg.textContent   = msgText;
  successUI.style.display  = 'flex';
  if (window.engineSound) engineSound.pause();  // leave bgMusic alone
}

function hideSuccessMenu(){
  successUI.style.display = 'none';
}

function goHome(){
  hideSuccessMenu();
  gameStarted = false;
  paused = false; isPaused = false;
  // Hide in-game HUDs
  infoEl.style.display = 'none';
  healthWrap.style.display = 'none';
  minimapEl.style.display = 'none';
  objectiveUI.style.display = 'none';
  // Hide level select and show start screen
  levelSelectEl.style.display = 'none';
  startEl.style.display = 'grid';
  if (window.engineSound) engineSound.pause();
}

// Buttons
btnNextLevel.onclick = () => {
  hideSuccessMenu();
  paused = false; isPaused = false;
  gameStarted = true;
  // wrap to level 1 after finishing level 4
  const next = (levelIndex + 1) % LEVELS.length;
  startLevel(next);
};

btnBackHome.onclick = goHome;




function startGame(){
  if (gameStarted) return;
  // Show level select instead of starting immediately
  startEl.style.display = 'none';
  refreshLevelSelectLabels();
  levelSelectEl.style.display = 'flex'; // centered via inline styles
  updateVehicleUI(); // NEW: highlight current vehicle choice

}


btnPlay.addEventListener('click', startGame);
startEl.addEventListener('keydown', (e)=>{ if (e.code === 'Enter') startGame(); });

btnYoutube.addEventListener('click', () => {
  openModal('YouTube videos (trailer + dev log)', YOUTUBE_HTML);
});


/* ===================== RENDERER ===================== */
const renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:'high-performance' });
renderer.setSize(innerWidth, innerHeight);
const START_DPR = Math.min(2, devicePixelRatio || 1);
renderer.setPixelRatio(START_DPR);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMappingExposure = 1.0;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.BasicShadowMap;
document.body.appendChild(renderer.domElement);



/* ===================== SCENE / CAMERA / LIGHTS ===================== */
const scene = new THREE.Scene();

// --- Fog presets ---
const FOG_DAY_COLOR   = 0x101018;  // subtle blue-grey (day)
const FOG_DAY_DENSITY = 0.012;

const FOG_NIGHT_COLOR   = 0x0a0b10; // deep blue (night)
const FOG_NIGHT_DENSITY = 0.03;

// Use clearColor (not scene.background) so the sky dome shows through
scene.background = null;
scene.fog = new THREE.FogExp2(FOG_DAY_COLOR, FOG_DAY_DENSITY);
renderer.setClearColor(FOG_DAY_COLOR, 1);

// Helper to change fog quickly
function setFog(color, density){
  scene.fog.color.set(color);
  scene.fog.density = density;
  renderer.setClearColor(color, 1);
}

// Smoothly fade fog color + density (safe: assumes scene.fog already exists)
function transitionFog(toColor, toDensity, duration = 2000){
  const fromColor   = scene.fog.color.clone();
  const fromDensity = scene.fog.density;
  const start = performance.now();
  const target = new THREE.Color(toColor);

  function step(){
    const t = Math.min(1, (performance.now() - start) / duration);
    scene.fog.color.lerpColors(fromColor, target, t);
    scene.fog.density = THREE.MathUtils.lerp(fromDensity, toDensity, t);
    renderer.setClearColor(scene.fog.color, 1);
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}



const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.03, 2000);
camera.position.set(0,6,12);
scene.add(camera);


// ===== Sky gradient dome =====
// Colors you can tweak:
const SKY_DAY_TOP    = 0x9dc7ff;  // zenith (up)
const SKY_DAY_BOTTOM = 0xeaf2ff;  // horizon (down)
const SKY_NIGHT_TOP    = 0x0a0b16;
const SKY_NIGHT_BOTTOM = 0x11131c;

// Small shader that blends between two colors by vertical direction
function makeSkyGradient(topHex, bottomHex, radius = 3000){
  const uniforms = {
    topColor:    { value: new THREE.Color(topHex) },
    bottomColor: { value: new THREE.Color(bottomHex) }
  };
  const vtx = `
    varying vec3 vWorldPos;
    void main(){
      vec4 wp = modelMatrix * vec4(position,1.0);
      vWorldPos = wp.xyz;
      gl_Position = projectionMatrix * viewMatrix * wp;
    }
  `;
  const frag = `
    varying vec3 vWorldPos;
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    void main(){
      // 0 at horizon, 1 at zenith (based on world up)
      float h = normalize(vWorldPos).y * 0.5 + 0.5;
      h = pow(h, 1.5);
      gl_FragColor = vec4(mix(bottomColor, topColor, h), 1.0);
    }
  `;
  const mat = new THREE.ShaderMaterial({
    uniforms, vertexShader: vtx, fragmentShader: frag,
    side: THREE.BackSide, depthWrite: false
  });
  const geo = new THREE.SphereGeometry(radius, 32, 16);
  return { mesh: new THREE.Mesh(geo, mat), uniforms };
}

// Use a radius safely inside the far plane
const SKY_RADIUS = Math.floor(camera.far * 0.9);
const sky = makeSkyGradient(SKY_DAY_TOP, SKY_DAY_BOTTOM, SKY_RADIUS);
sky.mesh.renderOrder = -1;   // draw behind everything
scene.add(sky.mesh);

function setSkyColors(topHex, bottomHex){
  sky.uniforms.topColor.value.set(topHex);
  sky.uniforms.bottomColor.value.set(bottomHex);
}


const amb = new THREE.AmbientLight(0xffffff, 0.45); scene.add(amb);

const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(25,35,10); sun.castShadow = true; sun.shadow.mapSize.set(512,512);
const SHADOW_HALF_EXTENT = 90;
sun.shadow.camera = new THREE.OrthographicCamera(-SHADOW_HALF_EXTENT, SHADOW_HALF_EXTENT, SHADOW_HALF_EXTENT, -SHADOW_HALF_EXTENT, 0.5, 400);
scene.add(sun); scene.add(sun.shadow.camera);

/* ===================== WORLD BASE ===================== */
const MAP_SIZE = 1200, MAP_HALF = MAP_SIZE/2;

const ground = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), new THREE.MeshLambertMaterial({ color:0xcfcfcf }));
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);



const divisions = Math.max(2, Math.round(MAP_SIZE/6));
const grid = new THREE.GridHelper(MAP_SIZE, divisions, 0x000000, 0x000000);
grid.material.transparent = true; grid.material.opacity = 0.45; grid.position.y = 0.0005; scene.add(grid);

/* ===================== ROAD / CROSSWALK TILES ===================== */
const ROAD_COLOR  = 0x2b2b2b;
const BASE_HEIGHT = 0.02;
const JOIN_EPS    = 1.0;
const ROAD_WIDTH  = 10, ROAD_LEN = 32, XWALK_LEN = 14;

function createRoadTile({length=32, width=10, baseHeight=BASE_HEIGHT, edgeWidth=0.18, dashLength=2.2, dashWidth=0.28}={}){
  const g = new THREE.Group();
  const asphalt = new THREE.Mesh(new THREE.PlaneGeometry(length, width), new THREE.MeshLambertMaterial({ color:ROAD_COLOR }));
  asphalt.rotation.x = -Math.PI/2; asphalt.position.y = baseHeight; asphalt.receiveShadow = true; g.add(asphalt);
  const makeStrip = (L,W,color)=>{ const m=new THREE.Mesh(new THREE.PlaneGeometry(L,W), new THREE.MeshBasicMaterial({color,side:THREE.DoubleSide})); m.rotation.x=-Math.PI/2; m.position.y=baseHeight+0.001; return m; };
  const edgeOffset = width/2 - edgeWidth/2;
  const left  = makeStrip(length, edgeWidth, 0xFFC107); left.position.z  =  edgeOffset;
  const right = makeStrip(length, edgeWidth, 0xFFC107); right.position.z = -edgeOffset;
  g.add(left, right);
  const gap = length/4;
  for (const x of [-gap,0,gap]) { const dash = makeStrip(dashLength, dashWidth, 0xFFFFFF); dash.position.x = x; g.add(dash); }
  return g;
}

function createCrosswalkTile({
  length=14, width=10, baseHeight=BASE_HEIGHT,
  edgeMargin=0.6, stubDepth=0.9, stripeThickness=0.28, gap=0.95,
  apronDepth=0.55, apronBleedX=1.20
} = {}) {
  const g = new THREE.Group();
  const base = new THREE.Mesh(new THREE.PlaneGeometry(length + 2*JOIN_EPS, width + 2*JOIN_EPS), new THREE.MeshLambertMaterial({ color:ROAD_COLOR }));
  base.rotation.x = -Math.PI/2; base.position.y = baseHeight; base.receiveShadow = true; g.add(base);
  const makeStrip = (L,W)=>{ const m=new THREE.Mesh(new THREE.PlaneGeometry(L,W), new THREE.MeshBasicMaterial({ color:0xFFFFFF, side:THREE.DoubleSide })); m.rotation.x=-Math.PI/2; m.position.y=baseHeight+0.0015; return m; };
  const usableX = length - 2*edgeMargin, usableZ = width - 2*edgeMargin;
  const countX = Math.max(2, Math.floor((usableX + gap)/(stripeThickness+gap)));
  const countZ = Math.max(2, Math.floor((usableZ + gap)/(stripeThickness+gap)));
  const startX = -length/2 + edgeMargin + stripeThickness/2;
  const startZ = -width/2  + edgeMargin + stripeThickness/2;
  for (let i=0;i<countX;i++){ const x=startX+i*(stripeThickness+gap);
    const top=makeStrip(stripeThickness, stubDepth); top.position.set(x, base.position.y+0.0015,  width/2 - stubDepth/2);
    const bot=makeStrip(stripeThickness, stubDepth); bot.position.set(x, base.position.y+0.0015, -width/2 + stubDepth/2); g.add(top,bot);
  }
  for (let j=0;j<countZ;j++){ const z=startZ+j*(stripeThickness+gap);
    const left =makeStrip(stubDepth, stripeThickness); left.position.set(-length/2 + stubDepth/2, base.position.y+0.0015, z);
    const right=makeStrip(stubDepth, stripeThickness); right.position.set( length/2 - stubDepth/2, base.position.y+0.0015, z); g.add(left,right);
  }
  const apronY = baseHeight - 0.0005, apronX = length + 2*JOIN_EPS + 2*apronBleedX;
  const apronGeo = new THREE.PlaneGeometry(apronX, apronDepth), apronMat = new THREE.MeshLambertMaterial({ color: ROAD_COLOR });
  const apronTop = new THREE.Mesh(apronGeo, apronMat); apronTop.rotation.x=-Math.PI/2; apronTop.position.set(0, apronY,  width/2 + apronDepth/2);
  const apronBot = apronTop.clone(); apronBot.position.z = -width/2 - apronDepth/2; g.add(apronTop, apronBot);
  return g;
}

/* ===================== Street lamp system ===================== */
const streetLights = [], streetBulbs = []; let streetLightsOn = true;
function createStreetLamp({ side="left", x=0, z=0 }) {
  const sideSign = side === "left" ? +1 : -1;
  const g = new THREE.Group();
  const teal=0x17a08f;
  const poleMat  = new THREE.MeshStandardMaterial({ color:teal, roughness:0.9, metalness:0.05 });
  const shadeMat = new THREE.MeshStandardMaterial({ color:teal, roughness:0.8, metalness:0.1 });
  const bulbMat  = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xffd45a, emissiveIntensity:0.35 });
  const H=5.2, r=0.07, baseR=0.14, baseH=0.25, inward=-sideSign;
  const pts=[ new THREE.Vector3(0,0,0), new THREE.Vector3(0,H*0.6,0), new THREE.Vector3(0,H*1.00,inward*0.5),
              new THREE.Vector3(0,H*1.05,inward*1.3), new THREE.Vector3(0,H*0.85,inward*1.7)];
  const curve=new THREE.CatmullRomCurve3(pts,false,'catmullrom',0.0);
  const arm=new THREE.Mesh(new THREE.TubeGeometry(curve,24,r,10,false),poleMat); arm.castShadow=arm.receiveShadow=true; g.add(arm);
  const foot=new THREE.Mesh(new THREE.CylinderGeometry(baseR,baseR,baseH,18),poleMat); foot.position.y=baseH/2; foot.castShadow=foot.receiveShadow=true; g.add(foot);
  const headPos=curve.getPoint(0.98);
  const bulb=new THREE.Mesh(new THREE.SphereGeometry(0.18,16,12),bulbMat); bulb.position.copy(headPos).add(new THREE.Vector3(0,-0.12,0)); g.add(bulb);
  const shade=new THREE.Mesh(new THREE.ConeGeometry(0.45,0.5,18),shadeMat); shade.rotation.x=Math.PI; shade.position.copy(headPos).add(new THREE.Vector3(0,0.05,0)); shade.castShadow=shade.receiveShadow=true; g.add(shade);
  const lamp=new THREE.PointLight(0xffd45a,0.25,9,2); lamp.position.copy(bulb.position); lamp.castShadow=false; g.add(lamp);
  streetLights.push(lamp); streetBulbs.push(bulb); g.position.set(x,0,z); return g;
}

function setStreetLights(on){
  streetLightsOn = on;

  // legacy/procedural lamps
  for (const L of streetLights) L.intensity = on ? 2.0 : 0.25;
  for (const b of streetBulbs) b.material.emissiveIntensity = on ? 2.2 : 0.35;

  // GLB street-lamp bulbs (the PointLights we attached)
  for (const p of glbStreetLights) p.intensity = on ? GLB_LAMP_ON_INTENSITY : GLB_LAMP_OFF_INTENSITY;
}


/* ===================== Car + headlights ===================== */
const car = new THREE.Group();
scene.add(car);

const headlightRig = new THREE.Group();
car.add(headlightRig);
// Load vehicle that matches the current selection (Truck/Sport/Bike)
ensureVehicle(selectedVehicle);   // <-- add this line

let headlightBulbs=[], headlightSpots=[], beamMeshes=[], headlightsOn=false;

function clearHeadlights(){ headlightRig.clear(); headlightBulbs.length=0; headlightSpots.length=0; beamMeshes.length=0; }
function rebuildHeadlightsFromBox(box){
  clearHeadlights();
  const size = new THREE.Vector3(); box.getSize(size);
  const min = box.min, max = box.max;
  const frontX = max.x - 0.05*size.x;
  const y = min.y + 0.42*size.y;
  const zOff = 0.28*size.z;

  const bulbMat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xfff2cc, emissiveIntensity:0.20 });
  function makeOne(zSign){
    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.07,14,12), bulbMat);
    bulb.position.set(frontX, y, zSign*zOff);
    const spot = new THREE.SpotLight(0xfff6d5, 0.0, 70, THREE.MathUtils.degToRad(26), 0.35, 1.4);
    spot.position.copy(bulb.position);
    const target = new THREE.Object3D(); target.position.set(frontX + 16, y - 0.40, zSign*zOff);
    headlightRig.add(target); spot.target = target;
    headlightRig.add(bulb, spot);
    headlightBulbs.push(bulb); headlightSpots.push(spot);
    const coneLen = 7.5, coneRad = Math.tan(spot.angle) * coneLen;
    const coneGeo = new THREE.ConeGeometry(coneRad, coneLen, 24, 1, true);
    const coneMat = new THREE.MeshBasicMaterial({ transparent:true, opacity:0.09, depthWrite:false, color:0xfff2cc });
    const cone = new THREE.Mesh(coneGeo, coneMat);
    cone.position.copy(bulb.position); cone.rotation.z = Math.PI/2; cone.rotateX(-0.40);
    headlightRig.add(cone); beamMeshes.push(cone);
  }
  makeOne(+1); makeOne(-1);
  setHeadlights(headlightsOn);
}
function setHeadlights(on){
  headlightsOn = on;
  for(const s of headlightSpots) s.intensity = on ? 8.5 : 0.0;
  for(const b of headlightBulbs) b.material.emissiveIntensity = on ? 1.8 : 0.20;
  for(const mesh of beamMeshes) mesh.visible = on;
}

/* ===== Load Pickup Truck (GLB) for the player ===== */
/* ===== Player vehicle loader/swapper (Truck/Sport/Bike) ===== */
let carModel = null;                // the current model attached under `car`
let vehicleCurrentType = null;      // 'Truck' | 'Sport' | 'Bike'
const VEHICLE_PREFABS = {};         // cache prepared roots by filename

function prepareGLBRootForUse(root){
  // standardize materials/shadows
  root.traverse(o=>{
    if (o.isMesh){
      o.castShadow = o.receiveShadow = true;
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      for (const m of mats){
        if (!m) continue;
        if (m.map) m.map.colorSpace = THREE.SRGBColorSpace;
        if ('wireframe' in m) m.wireframe = false;
      }
    }
  });
  return root;
}

function loadVehiclePrefab(filename){
  return new Promise((resolve)=>{
    // use cache if available
    if (VEHICLE_PREFABS[filename]){
      resolve(VEHICLE_PREFABS[filename]);
      return;
    }
    new GLTFLoader().setPath(VEHICLE_PATH).load(
      filename,
      (gltf)=>{
        const root = prepareGLBRootForUse(gltf.scene);
        VEHICLE_PREFABS[filename] = root; // keep an original for cloning
        resolve(root);
      },
      undefined,
      ()=> resolve(null) // failure -> null, we’ll fallback to a box
    );
  });
}

/** Load + attach the selected vehicle, keeping the same world size/fit. */
async function ensureVehicle(type='Truck'){
  if (vehicleCurrentType === type && carModel) return;

  // remove previous model (keep headlightRig which is a separate child)
  if (carModel){
    car.remove(carModel);
    carModel = null;
  }

  const file = VEHICLE_FILES[type] || TRUCK_GLB;
  const prefab = await loadVehiclePrefab(file);

  if (prefab){
    const node = prefab.clone(true);

    // Face +X like the truck did
    node.rotation.y = Math.PI/2;

    // Scale so overall length along X ≈ 3.9m (matches your original truck)
    let box = new THREE.Box3().setFromObject(node);
    const size = new THREE.Vector3(); box.getSize(size);
    const targetLen = 3.9;                         // keep driving feel identical
    const s = targetLen / Math.max(1e-6, size.x);
    node.scale.setScalar(s);

    // Sit on the ground
    box = new THREE.Box3().setFromObject(node);
    node.position.y = -box.min.y;

    car.add(node);
    carModel = node;

    // Rebuild headlight rig to fit the new bounds
    rebuildHeadlightsFromBox(box);
  } else {
    // Fallback simple box if a GLB fails to load
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(1.8,0.7,0.9),
      new THREE.MeshStandardMaterial({ color:0x888888 })
    );
    body.position.y = 0.35;
    body.castShadow = body.receiveShadow = true;
    car.add(body);
    carModel = body;

    const box = new THREE.Box3().setFromObject(body);
    rebuildHeadlightsFromBox(box);
  }

  vehicleCurrentType = type;
}


/* ===================== BUILDINGS, LOD & streaming ===================== */
let LARGE_PREFAB = null, LARGE_H = 1;
let SMALL_PREFAB = null, SMALL_H = 1;

function loadGLB(path, filename) {
  return new Promise((resolve) => {
    new GLTFLoader().setPath(path).load(filename, (gltf)=>{
      const obj = gltf.scene;
      obj.traverse(o=>{
        if (o.isMesh){
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for (const m of mats){
            if (!m) continue;
            if ('wireframe' in m) m.wireframe = false;
            if (m.map){
              m.map.colorSpace = THREE.SRGBColorSpace;
              m.map.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
              m.map.needsUpdate = true;
            }
          }
          o.castShadow = o.receiveShadow = true;
        }
      });
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3(); box.getSize(size);
      const height = Math.max(1e-6, size.y);
      obj.position.y = -box.min.y;
      resolve({ root: obj, height });
    }, undefined, (err)=>{ console.warn('GLB load failed:', filename, err); resolve(null); });
  });
}
function makeBuildingClone(targetHeight=20, preferSmall=false){
  const haveSmall = !!SMALL_PREFAB, haveLarge = !!LARGE_PREFAB;
  let src = null, srcH = 1;
  if (preferSmall && haveSmall) { src = SMALL_PREFAB; srcH = SMALL_H; }
  else if (haveLarge)          { src = LARGE_PREFAB; srcH = LARGE_H; }
  else if (haveSmall)          { src = SMALL_PREFAB; srcH = SMALL_H; }
  if (!src) {
    const h = targetHeight, w = 10, d = 10;
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshLambertMaterial({ color:0x9a9a3a }));
    m.position.y = h/2; m.castShadow = m.receiveShadow = true; return m;
  }
  const g = src.clone(true); const s = targetHeight / srcH; g.scale.setScalar(s);
  g.traverse(o=>{
    if (o.isMesh) {
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      if (!o.userData.stdMat) {
        o.userData.stdMat = mats[0];
        const basicOpts = { map: mats[0]?.map ?? null, color: mats[0]?.color ? mats[0].color.clone() : new THREE.Color(0xffffff), side: mats[0]?.side ?? THREE.FrontSide };
        o.userData.basicMat = new THREE.MeshBasicMaterial(basicOpts);
        if (basicOpts.map) basicOpts.map.colorSpace = THREE.SRGBColorSpace;
      }
      o.castShadow = true; o.receiveShadow = true;
    }
  });
  return g;
}

const roadSegments = [];
function rememberSegment(x,z,isX){ roadSegments.push({x,z,isX}); }

const ACTIVE_RADIUS = 180, HYST=30, SIDEWALK_CLEAR=14.0;

const active = new Map(); const pool=[];
function segKey(s){ return `${s.isX?'X':'Z'}:${s.x|0}:${s.z|0}`; }

function setObjLit(obj, lit, cast){
  obj.traverse(o=>{
    if (o.isMesh) {
      if (o.userData.stdMat && o.userData.basicMat) o.material = lit ? o.userData.stdMat : o.userData.basicMat;
      o.castShadow = !!cast;
    }
  });
}
function applyLOD(pair, dist){
  if (dist < 90){ setObjLit(pair.b1,true,true); setObjLit(pair.b2,true,true); }
  else if (dist < 150){ setObjLit(pair.b1,true,false); setObjLit(pair.b2,true,false); }
  else { setObjLit(pair.b1,false,false); setObjLit(pair.b2,false,false); }
}
function spawnPair(s, preferSmall=false){
  let pair = pool.pop();
  if (!pair) pair = { b1: makeBuildingClone(22, preferSmall), b2: makeBuildingClone(18, preferSmall) };
  else {
    pair.b1 = makeBuildingClone(22, preferSmall);
    pair.b2 = makeBuildingClone(18, preferSmall);
  }
  const off = ROAD_WIDTH/2 + SIDEWALK_CLEAR;
  if (s.isX){ pair.b1.position.set(s.x,0,s.z+off); pair.b2.position.set(s.x+10,0,s.z-off); }
  else      { pair.b1.position.set(s.x+off,0,s.z); pair.b2.position.set(s.x-off,0,s.z+10); }
  pair.b1.rotation.y = (Math.PI/2) * (Math.random()*4|0);
  pair.b2.rotation.y = (Math.PI/2) * (Math.random()*4|0);
  pair.b1.updateWorldMatrix(true,true); pair.b2.updateWorldMatrix(true,true);
  const d = Math.hypot(car.position.x - s.x, car.position.z - s.z); applyLOD(pair, d);
  scene.add(pair.b1, pair.b2); active.set(segKey(s), pair);
}
function despawnPair(key){ const pair=active.get(key); if(!pair)return; scene.remove(pair.b1,pair.b2); pool.push(pair); active.delete(key); }
let streamingEnabled=false;
function updateStreaming(nowMs){
  if (!streamingEnabled) return;
  if (!updateStreaming.last) updateStreaming.last=0;
  if (nowMs - updateStreaming.last < 250) return;
  updateStreaming.last = nowMs;

  for (const s of roadSegments){
    const d = Math.hypot(car.position.x - s.x, car.position.z - s.z);
    const key = segKey(s), isActive = active.has(key);
    if (!isActive && d < ACTIVE_RADIUS) spawnPair(s,false);
    if (isActive && d > ACTIVE_RADIUS + HYST) despawnPair(key);
  }
  for (const [key,pair] of active){
    const [,x,z] = key.split(':').map(Number);
    const d = Math.hypot(car.position.x - x, car.position.z - z);
    applyLOD(pair, d);
  }
}

/* ===================== Collisions ===================== */

// Streetlamp colliders (static AABBs)
const lampColliders = [];

const CAR_RADIUS = 0.9;
function box3ToAABB2D(box){ return { minX:box.min.x, maxX:box.max.x, minZ:box.min.z, maxZ:box.max.z }; }
function makeAABBFor(obj){ const b = new THREE.Box3().setFromObject(obj); return box3ToAABB2D(b); }
function addLampCollider(group){
  // Build an AABB once (lamps are static)
  const aabb = makeAABBFor(group);
  lampColliders.push({
    mesh: group,
    aabb,
    center: { x: group.position.x, z: group.position.z }
  });
}

function removeLampCollider(group){
  const i = lampColliders.findIndex(c => c.mesh === group);
  if (i >= 0) lampColliders.splice(i, 1);
}

function circleAABBResolve(cx,cz,r,aabb){
  const qx = Math.min(Math.max(cx, aabb.minX), aabb.maxX);
  const qz = Math.min(Math.max(cz, aabb.minZ), aabb.maxZ);
  const dx=cx-qx, dz=cz-qz, d2=dx*dx+dz*dz;
  if (d2 > r*r) return null;
  const inside = (cx>=aabb.minX && cx<=aabb.maxX && cz>=aabb.minZ && cz<=aabb.maxZ);
  if (inside){
    const l=cx-aabb.minX, rgt=aabb.maxX-cx, t=cz-aabb.minZ, b=aabb.maxZ-cz;
    const m=Math.min(l,rgt,t,b);
    if (m===l) return {x:r, z:0}; if (m===rgt) return {x:-r,z:0}; if (m===t) return {x:0,z:r}; return {x:0,z:-r};
  }
  const dist=Math.sqrt(Math.max(d2,1e-12)), pen=r-dist;
  return { x:(dx/dist)*pen, z:(dz/dist)*pen };
}

/* ===================== Obstacles (roadblocks → rubbish model) ===================== */
const obstacles = [];
let RUBBISH_PREFAB = null;

async function loadRubbishPrefab() {
  return new Promise((resolve) => {
    new GLTFLoader().setPath(VEHICLE_PATH).load(
      RUBBISH_GLB,
      (gltf) => {
        const root = gltf.scene;
        root.traverse(o => {
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
          }
        });

        // Scale rubbish so it roughly spans a roadblock width
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const targetWidth = Math.max(8, ROAD_WIDTH - 2); // tune to taste
        const s = targetWidth / Math.max(1e-6, size.x);
        root.scale.setScalar(s);

        // Sit on the ground
        const boxAfter = new THREE.Box3().setFromObject(root);
        root.position.y = -boxAfter.min.y;

        RUBBISH_PREFAB = root;
        resolve(true);
      },
      undefined,
      () => resolve(false) // if it fails, we’ll fall back to box geometry
    );
  });
}

/* ===================== Smashed Glass (slowdown hazard) ===================== */
let GLASS_PREFAB = null;
const glassHazards = [];

async function loadGlassPrefab() {
  return new Promise((resolve) => {
    new GLTFLoader().setPath(VEHICLE_PATH).load(
      GLASS_GLB,
      (gltf) => {
        const root = gltf.scene;
        root.traverse(o => {
          if (o.isMesh) {
            o.castShadow = false; // glass doesn’t cast shadow
            o.receiveShadow = true;
            if (o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
            o.material.transparent = true;
            o.material.opacity = 0.85;
          }
        });

        // scale glass patch to about road width
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const targetW = ROAD_WIDTH * 0.9 * 0.5; //change this to change glass size
        const s = targetW / Math.max(1e-6, size.x);
        root.scale.setScalar(s);
        root.position.y = -box.min.y + BASE_HEIGHT + 0.01;

        GLASS_PREFAB = root;
        resolve(true);
      },
      undefined,
      () => resolve(false)
    );
  });
}

async function applyPaverToGround(groundMesh) {
  // Compute city extents (for sensible repeat counts)
  let minX=Infinity,maxX=-Infinity,minZ=Infinity,maxZ=-Infinity;
  for (const s of roadSegments) {
    if (!s) continue;
    if (s.x < minX) minX = s.x; if (s.x > maxX) maxX = s.x;
    if (s.z < minZ) minZ = s.z; if (s.z > maxZ) maxZ = s.z;
  }
  if (!isFinite(minX)) { minX = -400; maxX = 400; minZ = -400; maxZ = 400; } // fallback
  const worldW = (maxX - minX) + 200;  // margin beyond roads
  const worldH = (maxZ - minZ) + 200;

  // Load GLB once and grab its material maps
  const gltf = await new Promise((res, rej) =>
    new GLTFLoader().setPath(VEHICLE_PATH).load(PAVER_GLB, res, undefined, rej)
  );

  // Find a mesh with a PBR material
  let srcMat = null;
  gltf.scene.traverse(o => { if (!srcMat && o.isMesh && o.material) srcMat = o.material; });

  // Extract maps (if present)
  const colorMap     = srcMat?.map || null;
  const normalMap    = srcMat?.normalMap || null;
  const roughnessMap = srcMat?.roughnessMap || null;
  const aoMap        = srcMat?.aoMap || null;

  // Estimate one-tile size from GLB bounds (so repeats match scale)
  let tileW = 2.0, tileH = 2.0;
  const bbox = new THREE.Box3().setFromObject(gltf.scene);
  if (!bbox.isEmpty()) {
    const size = new THREE.Vector3(); bbox.getSize(size);
    if (size.x > 0.05 && size.z > 0.05) { tileW = size.x; tileH = size.z; }
  }

  // Compute repeats so each GLB tile ~ its world size
  const repX = Math.max(1, Math.round(worldW / tileW));
  const repY = Math.max(1, Math.round(worldH / tileH));

  // Make all maps repeat, correct color space for base color
  [colorMap, normalMap, roughnessMap, aoMap].forEach(m => {
    if (!m) return;
    m.wrapS = m.wrapT = THREE.RepeatWrapping;
    m.repeat.set(repX, repY);
  });
  if (colorMap) colorMap.colorSpace = THREE.SRGBColorSpace;

  // Build new ground material
  const groundMat = new THREE.MeshStandardMaterial({
    map: colorMap || null,
    normalMap: normalMap || null,
    roughnessMap: roughnessMap || null,
    aoMap: aoMap || null,
    color: colorMap ? 0xffffff : 0x2a2a2a,
    roughness: 0.95,
    metalness: 0.0,
    polygonOffset: true,
    polygonOffsetFactor: 1,
    polygonOffsetUnits: 1
  });

  // Apply and drop the ground slightly to avoid z-fighting with roads/decals
  groundMesh.material = groundMat;
  groundMesh.position.y = BASE_HEIGHT - 0.02;
}


/* ===================== Street Lights (pair per ahead segment) ===================== */
let STREET_LIGHT_PREFAB = null;
let activeLampPair = null;   // { left, right, key }
const LAMP_SIDE_GAP = ROAD_WIDTH/2 + 1.6;  // put lamps between road and buildings
const LAMP_Y = BASE_HEIGHT;                // sit on the ground plane

async function loadStreetLightPrefab() {
  return new Promise((resolve) => {
    new GLTFLoader().setPath(VEHICLE_PATH).load(
      STREET_LIGHT_GLB,
      (gltf) => {
        const root = gltf.scene;
        root.traverse(o => {
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
          }
        });

        // scale to target height
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const s = STREET_LIGHT_TARGET_H / Math.max(1e-6, size.y);
        root.scale.setScalar(s);


        // sit on ground
        const box2 = new THREE.Box3().setFromObject(root);
        root.position.y = -box2.min.y + LAMP_Y;

        STREET_LIGHT_PREFAB = root;
        resolve(true);
      },
      undefined,
      () => resolve(false)
    );
  });
}

function orientLampTowardRoad(lamp, seg) {
  // “Center of this road segment”
  const center = new THREE.Vector3(seg.x, LAMP_Y, seg.z);

  // Yaw so the lamp’s “forward” faces the center line
  const dx = center.x - lamp.position.x;
  const dz = center.z - lamp.position.z;
  const yaw = Math.atan2(dz, dx);
  lamp.rotation.set(0, yaw + STREET_LIGHT_YAW_CORR, 0);

  // Nudge the whole lamp slightly along its local +X so the head hangs over the street
  if (STREET_LIGHT_OVERHANG !== 0) {
    const dir = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), lamp.rotation.y);
    lamp.position.addScaledVector(dir, STREET_LIGHT_OVERHANG);
  }
}

function attachBulbLight(lamp) {
  // world box -> local size (avoid double-scaling)
  const worldBox  = new THREE.Box3().setFromObject(lamp);
  const worldSize = new THREE.Vector3(); worldBox.getSize(worldSize);
  const localSize = worldSize.clone().divide(lamp.scale);

  // Rig is anchored at the head height (don’t move this when lowering the bulb)
  const rig = new THREE.Group();
  rig.position.set(
    GLB_LAMP_LOCAL_FORWARD,       // a bit toward the road
    localSize.y * 0.92,           // at the head height
    0
  );

  // Visible glowing bulb (this is what we lower)
  const bulbMesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.16, 14, 12),
    new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffd45a,
      emissiveIntensity: 1.3,
      roughness: 0.35
    })
  );
  bulbMesh.position.y = -GLB_LAMP_BULB_DROP; // ↓ only the bulb drops
  rig.add(bulbMesh);

  // Real light: downward spotlight
  const spot = new THREE.SpotLight(
    0xffd45a, GLB_LAMP_ON_INTENSITY, 18,
    THREE.MathUtils.degToRad(55), 0.45, 2
  );
  spot.castShadow = false;

  // Aim further down toward the road (independent of bulb drop)
  const target = new THREE.Object3D();
  target.position.set(0, -GLB_LAMP_TARGET_DROP, 1.0);
  rig.add(target);
  spot.target = target;

  rig.add(spot);
  lamp.add(rig);

  glbStreetLights.push(spot);
  return spot;
}





function spawnLampPairForSegment(seg) {
    // remove existing pair if any
  if (activeLampPair) {
    scene.remove(activeLampPair.left, activeLampPair.right);
    // ▼ add these two lines:
    removeLampCollider(activeLampPair.left);
    removeLampCollider(activeLampPair.right);
    activeLampPair = null;
  }


  // Compute the two sidewalk positions for this straight segment
  const leftPos  = new THREE.Vector3();
  const rightPos = new THREE.Vector3();

  if (seg.isX) {
    // road runs along +X/-X → lamps sit along ±Z sides
    leftPos.set(seg.x, LAMP_Y, seg.z + LAMP_SIDE_GAP);
    rightPos.set(seg.x, LAMP_Y, seg.z - LAMP_SIDE_GAP);
  } else {
    // road runs along +Z/-Z → lamps sit along ±X sides
    leftPos.set(seg.x + LAMP_SIDE_GAP, LAMP_Y, seg.z);
    rightPos.set(seg.x - LAMP_SIDE_GAP, LAMP_Y, seg.z);
  }

  // === Use the legacy GREEN procedural lamp (with glowing bulb + point light)
  const leftLamp  = createStreetLamp({ side: "left",  x: leftPos.x,  z: leftPos.z  });
  const rightLamp = createStreetLamp({ side: "right", x: rightPos.x, z: rightPos.z });

    // Add to scene and remember
  scene.add(leftLamp, rightLamp);
  activeLampPair = { left: leftLamp, right: rightLamp, key: segKey(seg) };

  // ▼ register their AABBs for collisions
  addLampCollider(leftLamp);
  addLampCollider(rightLamp);

  // Make sure intensity matches current day/night toggle
  setStreetLights(streetLightsOn);

}

/** Choose the next straight road segment in front of the car and ensure lamps exist there. */
function ensureAheadLampPair() {
  // If we already spawned for the current target segment, do nothing
  const fwd = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);
  const useX = Math.abs(fwd.x) >= Math.abs(fwd.z); // which axis dominates -> straight segment type
  const maxAheadDist = ROAD_LEN * 1.5;

  let best = null;
  let bestProj = 0;

  for (const s of roadSegments) {
    if (useX !== s.isX) continue;

    // vector from car to segment center
    const vx = s.x - car.position.x;
    const vz = s.z - car.position.z;
    // projection along forward (must be > 0 to be "ahead")
    const proj = vx*fwd.x + vz*fwd.z;
    if (proj <= 0) continue;
    if (proj > maxAheadDist) continue;

    // ensure we're roughly on the same lateral line (within half road width + sidewalk clearance)
    if (s.isX) {
      if (Math.abs(s.z - car.position.z) > ROAD_WIDTH/2 + SIDEWALK_CLEAR) continue;
    } else {
      if (Math.abs(s.x - car.position.x) > ROAD_WIDTH/2 + SIDEWALK_CLEAR) continue;
    }

    if (!best || proj < bestProj) { best = s; bestProj = proj; }
  }

  if (!best) return;

  const key = segKey(best);
    if (activeLampPair?.key === key) return; // already spawned for this ahead segment

  // We’re moving onto a new "ahead straight segment":
  spawnLampPairForSegment(best);

  // === Power box cadence: roughly 1 per 4 straight segments ===
  pbSegCounter++;
  if (pbSegCounter >= 4) {
    pbSegCounter = 0;
    if (!hasNearbyPowerBox(best.x, best.z)) {
      addPowerBoxAt(best.x, best.z);
    }
  }

}

/* ===================== GAME STATE & LEVELS ===================== */
// 3 simple stages (tweak freely)
const LEVELS = [
  { name:'Dawn Delivery',  goals:3, time:180, night:false, pursuers:0, roadblocks:1, glass:1 },
  { name:'Night Shift',    goals:4, time:150, night:true,  pursuers:1, roadblocks:2, glass:2 },
  { name:'Lockdown',       goals:5, time:150, night:true,  pursuers:3, roadblocks:3, glass:3 },
  // Level 4: rescue Pieter Steph – 1 target, same time & pursuers as Level 3
  { name:'The Rescue',     goals:1, time:150, night:true,  pursuers:3, roadblocks:3, glass:3 },
];


let levelIndex = 0;
let deliveries = 0;
let timeLeft   = 0;
let paused     = false;

const objectiveUI  = document.getElementById('objectiveUI');
const hudLevelEl   = document.getElementById('hudLevel');
const hudTimerEl   = document.getElementById('hudTimer');
const hudGoalsEl   = document.getElementById('hudGoals');

function fmtTime(sec){
  sec = Math.max(0, Math.floor(sec));
  const m = (sec/60)|0, s = sec%60;
  return `${m.toString().padStart(1,'0')}:${s.toString().padStart(2,'0')}`;
}

function setDay(){
  sun.intensity = 0.8;
  amb.intensity = 0.45;
  renderer.toneMappingExposure = 1.0;

  // Fog + sky for day (smooth)
  transitionFog(FOG_DAY_COLOR, FOG_DAY_DENSITY);
  setSkyColors(SKY_DAY_TOP, SKY_DAY_BOTTOM);

  setStreetLights(true);
  setHeadlights(true);
}

function setNight(){
  sun.intensity = 0.04;
  amb.intensity = 0.06;
  renderer.toneMappingExposure = 1.15;

  // Fog + sky for night (smooth)
  transitionFog(FOG_NIGHT_COLOR, FOG_NIGHT_DENSITY);
  setSkyColors(SKY_NIGHT_TOP, SKY_NIGHT_BOTTOM);

  setStreetLights(true);
  setHeadlights(true);
}


function updateObjectiveHUD(){
  const L = LEVELS[levelIndex];
  hudLevelEl.textContent = `Level ${levelIndex+1} — ${L.name}`;
  hudTimerEl.textContent = fmtTime(timeLeft);
  hudGoalsEl.textContent = `${deliveries}/${L.goals}`;
}

/* cleanups used when (re)starting a level */
function clearObstaclesAndHazards(){
  for (const o of obstacles) scene.remove(o.mesh);
  obstacles.length = 0;
  for (const g of glassHazards) scene.remove(g.mesh);
  glassHazards.length = 0;
}
function clearAgents(){
  for (const a of agents) scene.remove(a.mesh);
  agents.length = 0;
}
function clearGoal(){
  // keep local refs before we null out globals
  const node  = goalNode;
  const light = goalLight;

  // remove extras attached to the goal model
  if (node?.userData?.ring)  scene.remove(node.userData.ring);
  if (node?.userData?.beam)  scene.remove(node.userData.beam);
  if (node?.userData?.flare) scene.remove(node.userData.flare);

  // remove the goal model itself
  if (node) scene.remove(node);

  // remove the spotlight and its target (the target was added to the scene too)
  if (light?.target) scene.remove(light.target);
  if (light) scene.remove(light);

  goalNode  = null;
  goalLight = null;

  clearTrail();
}


function randomSegmentFarFrom(x, z, minDist=DEST_MIN_DIST){
  const c = [];
  for (const s of roadSegments){
    if (Math.hypot(s.x-x, s.z-z) >= minDist) c.push(s);
  }
  return c.length ? c[Math.random()*c.length|0] : null;
}

/* Start / End / Goal flow */
function startLevel(i){
  levelIndex = THREE.MathUtils.clamp(i, 0, LEVELS.length-1);
  const L = LEVELS[levelIndex];

    // ensure fail UI is hidden and player state reset
  hideFailMenu?.();
  paused = false;
  gameStarted = true;
  health = 100; setHealthBar(health);
  speed = 0; keys.clear();

  // reset player to spawn
  car.position.set(carStartX, 0, spawnZ);
  heading = 0;
  car.rotation.set(0, heading, 0);


  // reset state
  deliveries = 0;
  timeLeft   = L.time;
  paused     = false;

  // world prep
  clearObstaclesAndHazards();
  clearAgents();
  clearGoal();

  // lighting
  if (L.night) setNight(); else setDay();

  // spawn initial pursuers
  for (let k=0;k<L.pursuers;k++) spawnDroneNearPlayer(12, 20);

  // a few roadblocks & glass on random roads (not right at the car)
  for (let r=0;r<L.roadblocks;r++){
    const seg = randomSegmentFarFrom(car.position.x, car.position.z, ROAD_LEN*4) || roadSegments[(Math.random()*roadSegments.length)|0];
    addRoadblockAt(seg.x, seg.z, seg.isX ?? true);
  }
  for (let g=0; g<L.glass; g++){
    const seg = randomSegmentFarFrom(car.position.x, car.position.z, ROAD_LEN*4) || roadSegments[(Math.random()*roadSegments.length)|0];
    addGlassAt(seg.x, seg.z);
  }

 


  // place first destination + bread-crumbs
  spawnGoalAndTrail();
  // NEW: show the parcel drop + toast at level start
  dropParcel();
  objectiveUI.style.display = 'block';
  updateObjectiveHUD();
}

function endLevel(success){
  if (!success){
    showFailMenu("Time's up!");
    return;
  }

  // We reached all goals / the rescue target.
  // Show the success overlay with buttons instead of auto-advancing.
  if (levelIndex === 3) {
    // Special text for Level 4 (rescue)
    showSuccessMenu('Rescue Complete', 'You found Pieter Steph! 🎉');
  } else {
    showSuccessMenu('Mission Successfully Completed', 'Nice work — deliveries made in time!');
  }
}



function onReachGoal(){
  deliveries++;

   // remove current goal visuals (flag, beam, flare, ring, light)
  clearGoal();

    //  Confetti on each goal
  if (window.confetti) {
    const base = { origin: { y: 0.6 }, gravity: 0.9 };
    confetti({ particleCount: 160, spread: 70, startVelocity: 45, ...base });
    setTimeout(() => confetti({ particleCount: 120, spread: 90, startVelocity: 36, ...base }), 220);
  }

    //  short success chime
  playSuccessSfx();


  

    //  Add 30 seconds to the timer if it hasn’t already run out
  if (timeLeft > 0) {
    timeLeft += 30;
    updateObjectiveHUD(); // refresh the displayed time
    showToast('+30s Bonus Time!', 1400);
  }



  updateObjectiveHUD();

  const L = LEVELS[levelIndex];
  if (deliveries >= L.goals){
    endLevel(true);
  } else {
    // place another far goal
    const startSeg = nearestRoadCenter(car.position);
    const targetSeg = randomFarRoad(DEST_MIN_DIST, DEST_MAX_DIST);
 
    if (startSeg && targetSeg) {
      placeGoalAt(targetSeg);
      buildOrthogonalPath(startSeg, targetSeg);
      // NEW: show parcel received for the next delivery
      dropParcel();
    }
  }
}



/* ===================== Goal & illuminated trail ===================== */
let GOAL_PREFAB = null;
let goalNode = null;
let goalLight = null;
const trailGroup = new THREE.Group(); scene.add(trailGroup);
const trailLights = [];

// --- Exclusion zone so obstacles don't spawn on top of the goal/rescue ---
let goalNoSpawnBox = null;

/** Rebuild the exclusion box around whatever node represents the goal. */
function updateGoalNoSpawnBoxFrom(node, padding = 4) {
  if (!node) { goalNoSpawnBox = null; return; }
  goalNoSpawnBox = new THREE.Box3().setFromObject(node).expandByScalar(padding);
}

/** Quick XY test (XZ in world) – use center point with a little extra margin. */
function isInsideGoalNoSpawn(x, z, extra = 0) {
  if (!goalNoSpawnBox) return false;
  // Expand a copy so we don't mutate the original
  const b = goalNoSpawnBox.clone().expandByScalar(extra);
  return (x > b.min.x && x < b.max.x && z > b.min.z && z < b.max.z);
}


// Goal placement distances (closer, but not too close)
const DEST_MIN_DIST = ROAD_LEN * 5;   // was *8 — closer than before
const DEST_MAX_DIST = ROAD_LEN * 12;  // cap so goals aren’t *too* far

// ----- Minimap breadcrumb trail -----
const MINI_TRAIL = [];


const TRAIL_STEP = 2.4;                     // spacing between breadcrumbs (meters)
const TRAIL_DISC_SIZE = 0.9;                // visual size of breadcrumb
const TRAIL_LIGHT_INTENSITY = 0.7;          // each breadcrumb’s soft glow
const GOAL_REACH_RADIUS = 2.2;         // distance from flag to count as delivered


async function loadGoalPrefab() {
  return new Promise((resolve) => {
    new GLTFLoader().setPath(VEHICLE_PATH).load(
      GOAL_FLAG_GLB,
      (gltf) => {
        const root = gltf.scene;
        root.traverse(o=>{
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
          }
        });
        // scale flag to a nice height (~2.6m)
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const targetH = 2.6;
        const s = targetH / Math.max(1e-6, size.y);
        root.scale.setScalar(s);

        // sit on ground plane
        const box2 = new THREE.Box3().setFromObject(root);
        root.position.y = -box2.min.y + BASE_HEIGHT;

        GOAL_PREFAB = root;
        resolve(true);
      },
      undefined,
      () => resolve(false)
    );
  });
}

/* ===== Load rescue (person) prefab ===== */
let RESCUE_PREFAB = null;

async function loadRescuePrefab() {
  return new Promise((resolve) => {
    new GLTFLoader().setPath(VEHICLE_PATH).load(
      RESCUE_GLB,
      (gltf) => {
        const root = gltf.scene;
        root.traverse(o => {
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
          }
        });

        // Scale to human height (~1.8m)
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const targetH = 1.8;
        const s = targetH / Math.max(1e-6, size.y);
        root.scale.setScalar(s);

       // Sit on ground and lift slightly so it never clips
        const box2 = new THREE.Box3().setFromObject(root);
        root.position.y = -box2.min.y + BASE_HEIGHT + 0.28;


        RESCUE_PREFAB = root;
        resolve(true);
      },
      undefined,
      () => resolve(false)
    );
  });
}


function nearestRoadCenter(pos){
  let best = null, bestD2 = Infinity;
  for (const s of roadSegments){
    const dx = s.x - pos.x, dz = s.z - pos.z;
    const d2 = dx*dx + dz*dz;
    if (d2 < bestD2){ bestD2 = d2; best = s; }
  }
  return best;
}

function randomFarRoad(minDist, maxDist = Infinity){
  const choices = [];
  const min2 = minDist * minDist;
  const max2 = maxDist * maxDist;
  for (const s of roadSegments){
    const dx = s.x - car.position.x, dz = s.z - car.position.z;
    const d2 = dx*dx + dz*dz;
    if (d2 >= min2 && d2 <= max2) choices.push(s);
  }
  if (!choices.length) return null;
  return choices[Math.random()*choices.length | 0];
}


function clearTrail(){
  // remove breadcrumbs + lights
  for (const L of trailLights) scene.remove(L);
  trailLights.length = 0;
  while (trailGroup.children.length){
    const c = trailGroup.children.pop();
    if (c.geometry) c.geometry.dispose?.();
    if (c.material) c.material.dispose?.();
  }
    // also clear the minimap copy
  MINI_TRAIL.length = 0;
}

function addTrailMarker(x, z) {
  // glowing sprite disc only, no point light
  const mat = new THREE.SpriteMaterial({
    color: 0x66ccff,
    transparent: true,
    opacity: 0.8,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const sp = new THREE.Sprite(mat);
  sp.scale.set(TRAIL_DISC_SIZE, TRAIL_DISC_SIZE, TRAIL_DISC_SIZE);
  sp.position.set(x, BASE_HEIGHT + 0.05, z);
  trailGroup.add(sp);
}


function addTrailLine(x1, z1, x2, z2){
  // march from (x1,z1) to (x2,z2) placing markers
  const dx = x2 - x1, dz = z2 - z1;
  const len = Math.hypot(dx, dz);
  if (len < 1e-3) return;
  const nx = dx / len, nz = dz / len;
  for (let d = 0; d <= len; d += TRAIL_STEP){
    addTrailMarker(x1 + nx*d, z1 + nz*d);
  }
    // ----- Minimap: sample this straight segment into 2D points -----
  {
    const dx2 = x2 - x1, dz2 = z2 - z1;
    const dist = Math.hypot(dx2, dz2);

    // roughly one point every ~ROAD_LEN/2; at least 2 points
    const steps = Math.max(2, Math.round(dist / (ROAD_LEN * 0.5)));
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = x1 + dx2 * t;
      const z = z1 + dz2 * t;

      // avoid duplicating the exact previous point
      const last = MINI_TRAIL[MINI_TRAIL.length - 1];
      if (!last || last.x !== x || last.y !== z) {
        MINI_TRAIL.push(new THREE.Vector2(x, z)); // note: .y stores z
      }
    }
  }
}

function buildOrthogonalPath(startSeg, targetSeg){
  // Always stay on roads: snap the turn to the nearest road COLUMN and ROW.
  // Walk: (start row) -> (pivot column) -> (target row) -> (goal along row)
  clearTrail();

  // Start row and target row snapped to real road rows/cols
  const startRowZ  = nearestGridZ(startSeg.z);
  const targetRowZ = nearestGridZ(targetSeg.z);

  // Choose a real column to turn on (closest road column near the target)
  const pivotColX  = nearestGridX(targetSeg.x);

  // Legs:
  // 1) along the start row from the car’s current road X to the pivot column
  if (Math.abs(pivotColX - startSeg.x) > 1e-3) {
    addTrailLine(startSeg.x, startRowZ, pivotColX, startRowZ);
  }

  // 2) down/up the pivot column to the target row
  if (Math.abs(targetRowZ - startRowZ) > 1e-3) {
    addTrailLine(pivotColX, startRowZ, pivotColX, targetRowZ);
  }

  // 3) along the target row to the actual goal X (can be anywhere on that row)
  if (Math.abs(targetSeg.x - pivotColX) > 1e-3) {
    addTrailLine(pivotColX, targetRowZ, targetSeg.x, targetRowZ);
  }

   // --- ensure the trail visibly reaches the goal ---
  addTrailMarker(targetSeg.x, targetSeg.z);
  MINI_TRAIL.push(new THREE.Vector2(targetSeg.x, targetSeg.z));
}


function placeGoalAt(seg){
  // remove previous goal if any
  if (goalNode) { scene.remove(goalNode); goalNode = null; }
  if (goalLight){ scene.remove(goalLight); goalLight = null; }

  // clone prefab
  const root = GOAL_PREFAB ? GOAL_PREFAB.clone(true) :
    new THREE.Mesh(new THREE.ConeGeometry(0.6, 2.2, 18),
                   new THREE.MeshStandardMaterial({ color:0xff3b3b, metalness:0.2, roughness:0.8 }));
  root.position.set(seg.x, root.position.y, seg.z);
  root.rotation.y = Math.PI * 0.5 * (Math.random()*4|0);
  scene.add(root);
  goalNode = root;
  // Rebuild the no-spawn exclusion zone around the goal
updateGoalNoSpawnBoxFrom(goalNode, 4); // increase padding if needed


    // Glow ring under the goal for visibility
  const ringGeo = new THREE.RingGeometry(0.55, 0.95, 48);
  const ringMat = new THREE.MeshBasicMaterial({
    color: 0xffe08a,
    transparent: true,
    opacity: 0.75,
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending
  });
  const goalRing = new THREE.Mesh(ringGeo, ringMat);
  goalRing.rotation.x = -Math.PI / 2;
  goalRing.position.set(seg.x, BASE_HEIGHT + 0.01, seg.z);
  scene.add(goalRing);

  // keep a handle so we can animate it
  goalNode.userData.ring = goalRing;


  // beacon light
  const L = new THREE.SpotLight(0xffe08a, 4.5, 26, THREE.MathUtils.degToRad(55), 0.45, 2.0);
  L.position.set(seg.x, 6.2, seg.z);
  const target = new THREE.Object3D(); target.position.set(seg.x, BASE_HEIGHT + 0.2, seg.z);
  scene.add(target); L.target = target;
  scene.add(L);
  goalLight = L;

    // --- extra visibility: vertical beam + camera-facing flare ---
  // Vertical “beacon” beam (additive, transparent)
  const beamGeo = new THREE.CylinderGeometry(0.45, 1.25, 10, 16, 1, true);
  const beamMat = new THREE.MeshBasicMaterial({
    color: 0x88c6ff,
    transparent: true,
    opacity: 0.22,
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const beam = new THREE.Mesh(beamGeo, beamMat);
  beam.position.set(seg.x, BASE_HEIGHT + 5.0, seg.z); // centered on flag, ~10m tall
  scene.add(beam);

  goalNode.userData.beam  = beam;
  

}

function placeRescueAt(seg){
  // remove previous goal if any
  if (goalNode) { scene.remove(goalNode); goalNode = null; }
  if (goalLight){ scene.remove(goalLight); goalLight = null; }

  // Use the person model; fallback cone if load failed
  const root = RESCUE_PREFAB ? RESCUE_PREFAB.clone(true)
    : new THREE.Mesh(new THREE.CapsuleGeometry(0.35, 1.0, 8, 16),
                     new THREE.MeshStandardMaterial({ color:0x3bb3ff, metalness:0.2, roughness:0.8 }));
  root.position.set(seg.x, root.position.y, seg.z);
  scene.add(root);
  goalNode = root;
  updateGoalNoSpawnBoxFrom(goalNode, 4);


   // --- add glow ring + brighter beacon ---
  {
    const ringGeo = new THREE.RingGeometry(0.35, 0.55, 32);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0x6fc6ff,
      transparent: true,
      opacity: 0.7,
      side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.set(seg.x, BASE_HEIGHT + 0.015, seg.z);
    scene.add(ring);
  }

  // Replace the point light with a taller, brighter locator beacon
  if (goalLight) { scene.remove(goalLight); goalLight = null; }
  const beacon = new THREE.SpotLight(0x88c6ff, 5.0, 26, THREE.MathUtils.degToRad(55), 0.45, 1.8);
  beacon.position.set(seg.x, 6.0, seg.z);
  const tgt = new THREE.Object3D();
  tgt.position.set(seg.x, BASE_HEIGHT + 0.2, seg.z);
  scene.add(tgt);
  beacon.target = tgt;
  scene.add(beacon);
  goalLight = beacon;
}



function spawnGoalAndTrail(){
  // start at nearest road center to the car
  const startSeg = nearestRoadCenter(car.position);
  const targetSeg = randomFarRoad(DEST_MIN_DIST, DEST_MAX_DIST);

  if (!startSeg || !targetSeg) return;

    if (levelIndex === 3) {
    // Level 4: place the person instead of the flag
    placeRescueAt(targetSeg);
  } else {
    placeGoalAt(targetSeg);
  }
  buildOrthogonalPath(startSeg, targetSeg);

}



function addGlassAt(x, z) {
  let mesh;
  if (GLASS_PREFAB) {
    mesh = GLASS_PREFAB.clone(true);
    mesh.position.set(x, BASE_HEIGHT + 0.01, z);
    mesh.rotation.y = (Math.PI/2) * (Math.random()*4|0);
  } else {
    // fallback plane
    const geo = new THREE.PlaneGeometry(ROAD_WIDTH*0.9, ROAD_WIDTH*0.9);
    const mat = new THREE.MeshBasicMaterial({ color: 0x55ffff, opacity: 0.5, transparent: true, side: THREE.DoubleSide });
    mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = -Math.PI/2;
    mesh.position.set(x, BASE_HEIGHT + 0.01, z);
  }
  scene.add(mesh);
  const aabb = makeAABBFor(mesh);
  glassHazards.push({ mesh, aabb });
  return mesh;
}

/* ===================== Power Boxes (yellow question block) ===================== */
let POWER_BOX_PREFAB = null;
const powerBoxes = [];

/** Load the GLB once and store a prefab */
async function loadPowerBoxPrefab() {
  return new Promise((resolve) => {
    new GLTFLoader().setPath(VEHICLE_PATH).load(
      POWER_BOX_GLB,
      (gltf) => {
        const root = gltf.scene;
        root.traverse(o => {
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
          }
        });

        // Scale to a nice world size (~1.4m cube)
        let box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const target = 1.4;
        const longest = Math.max(size.x, size.y, size.z) || 1;
        const s = target / longest;
        root.scale.setScalar(s);

        // Sit on the ground plane
        box = new THREE.Box3().setFromObject(root);
        root.position.y = -box.min.y + BASE_HEIGHT;

        POWER_BOX_PREFAB = root;
        resolve(true);
      },
      undefined,
      () => resolve(false)
    );
  });
}

/** Clone + place a power box at (x,z) */
function addPowerBoxAt(x, z) {
  let mesh;
  if (POWER_BOX_PREFAB) {
    mesh = POWER_BOX_PREFAB.clone(true);
    mesh.position.set(x, mesh.position.y, z);
    mesh.rotation.y = (Math.PI/2) * (Math.random()*4|0); // 0/90/180/270
  } else {
    // Fallback simple box if GLB fails
    const geo = new THREE.BoxGeometry(1.4, 1.4, 1.4);
    const mat = new THREE.MeshStandardMaterial({ color: 0xffd23c, roughness: 0.6, metalness: 0.05 });
    mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, BASE_HEIGHT + 0.7, z);
    mesh.castShadow = mesh.receiveShadow = true;
  }

  scene.add(mesh);
  const aabb = makeAABBFor(mesh);
  powerBoxes.push({ mesh, aabb });
  return mesh;
}

// Prevent clustering: is there a box already very close?
function hasNearbyPowerBox(x, z, minDist = ROAD_LEN * 1.2) {
  const m2 = minDist * minDist;
  for (const pb of powerBoxes) {
    const dx = pb.mesh.position.x - x;
    const dz = pb.mesh.position.z - z;
    if (dx*dx + dz*dz < m2) return true;
  }
  return false;
}

// Count how many "ahead straight segments" we’ve moved through
let pbSegCounter = 0;

/* ===================== Reversed Controls ===================== */
let reversedControls = false;
let reverseUntil = 0;

function isReversedActive() {
  return reversedControls && performance.now() < reverseUntil;
}

function activateReversed(ms = 3000) {
  reversedControls = true;
  reverseUntil = performance.now() + ms;
  showToast('Controls reversed!', 1000);
}

function endReversed() {
  if (!reversedControls) return;
  reversedControls = false;
  showToast('Controls normal', 900);
}

/* ===================== Fog Vision (visibility cut) ===================== */
let fogUntil = 0;
const fogBackup = { color: new THREE.Color(), density: 0, active: false };

function isFogActive(){ return performance.now() < fogUntil; }

// Show/Hide the highlighted path (3D breadcrumbs + minimap polyline)
function setTrailVisible(v){
  // 3D breadcrumbs (group or individual markers)
  if (window.trailGroup) trailGroup.visible = v;
  if (window.trailMarkers?.length) window.trailMarkers.forEach(m => m.visible = v);

  // Minimap polyline (single Line or Line2)
  if (window.miniTrailLine) miniTrailLine.visible = v;

  // If your minimap uses a sprite trail instead, also gate that here
  if (window.miniTrailSprites?.length) window.miniTrailSprites.forEach(s => s.visible = v);
}


function activateFog(ms = 4000){
  fogUntil = performance.now() + ms;

  // backup current fog so we can restore *exactly*
  if (scene.fog) {
    fogBackup.color.copy(scene.fog.color);
    fogBackup.density = scene.fog.density;
    fogBackup.active = true;
  }

  // ramp to heavy, grey-ish fog for a few seconds
  // (feel free to tweak the color or the density 0.09 → 0.12 for thicker)
  transitionFog(0x777b86, Math.max(scene.fog?.density ?? 0.0, 0.09), 500);
  showToast('Fog! visibility reduced', 900);
   // HIDE PATH for duration of fog
  setTrailVisible(false);

  // safety restore (in case we’re off-screen or paused)
  setTimeout(() => {
    if (!isFogActive() && fogBackup.active) {
      transitionFog(fogBackup.color.getHex(), fogBackup.density, 500);
      fogBackup.active = false;
      // SHOW PATH again when fog ends
      setTrailVisible(true);
    }
  }, ms);
}





/* ===================== Ghost Mode (pass-through) ===================== */
let isGhostMode = false;
let ghostUntil  = 0;

function isGhostActive(){
  return isGhostMode && performance.now() < ghostUntil;
}

function setCarGhostVisual(on){
  // Slightly transparent + a bit more emissive while active
  car.traverse(o=>{
    if (!o.isMesh || !o.material) return;
    const mats = Array.isArray(o.material) ? o.material : [o.material];
    for (const m of mats){
      if (!m) continue;
      m.userData ??= {};
      if (on){
        if (m.userData._origTransparent === undefined) m.userData._origTransparent = m.transparent;
        if (m.userData._origOpacity     === undefined) m.userData._origOpacity     = m.opacity ?? 1;
        if (m.emissive && m.userData._origEmissive === undefined) m.userData._origEmissive = m.emissiveIntensity ?? 0;

        m.transparent = true;
        m.opacity = 0.45;
        if (m.emissive) m.emissiveIntensity = (m.userData._origEmissive ?? 0) + 0.6;
      } else {
        if (m.userData._origTransparent !== undefined) m.transparent = m.userData._origTransparent;
        if (m.userData._origOpacity     !== undefined) m.opacity     = m.userData._origOpacity;
        if (m.emissive && m.userData._origEmissive !== undefined) m.emissiveIntensity = m.userData._origEmissive;
      }
    }
  });
}

function activateGhostMode(ms=3000){
  isGhostMode = true;
  ghostUntil  = performance.now() + ms;
  setCarGhostVisual(true);
  showToast('Ghost mode: pass through!', 1200);
}

function endGhostMode(){
  if (!isGhostMode) return;
  isGhostMode = false;
  setCarGhostVisual(false);
  showToast('Ghost mode ended', 900);
}






// ---- Streaming spawn along the path (≈ one every ~4 segments) ----
let pbTraveled = 0;                         // meters since last spawn
let pbNextEvery = 0;                        // meters until next spawn
const PB_MIN_SEG = 3.5;                     // ~3.5 segments
const PB_MAX_SEG = 5.0;                     // up to ~5 segments
const _pbTmp = new THREE.Vector3();
const _pbLastPos = new THREE.Vector3();

function resetPowerBoxProgress() {
  pbTraveled = 0;
  pbNextEvery = ROAD_LEN * (PB_MIN_SEG + Math.random() * (PB_MAX_SEG - PB_MIN_SEG));
  _pbLastPos.copy(car.position);
}

// Pick a road segment roughly ahead of the car
function pickAheadRoadSegment() {
  const fwd = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);
  let best = null, bestDot = 0, bestD2 = Infinity;

  for (const seg of roadSegments) {
    const v = _pbTmp.set(seg.x - car.position.x, 0, seg.z - car.position.z);
    const dot = v.dot(fwd);          // >0 means in front
    if (dot <= 0) continue;
    const d2 = v.lengthSq();
    // Prefer most forward, break ties by closer
    if (dot > bestDot || (Math.abs(dot - bestDot) < 1e-3 && d2 < bestD2)) {
      best = seg; bestDot = dot; bestD2 = d2;
    }
  }
  return best;
}

function tickPowerBoxProgress() {
  // accumulate distance the car actually moved this frame
  const moved = _pbTmp.copy(car.position).sub(_pbLastPos).length();
  if (moved > 0) {
    pbTraveled += moved;
    _pbLastPos.copy(car.position);
  }

  if (pbTraveled >= pbNextEvery) {
    pbTraveled = 0;
    pbNextEvery = ROAD_LEN * (PB_MIN_SEG + Math.random() * (PB_MAX_SEG - PB_MIN_SEG));

    // choose an ahead segment and drop a box there
    const seg = pickAheadRoadSegment();
    if (seg) {
      // avoid placing on top of an existing box
      let farEnough = true;
      for (const pb of powerBoxes) {
        if (pb.mesh.position.distanceToSquared(_pbTmp.set(seg.x, pb.mesh.position.y, seg.z)) < (ROAD_LEN * ROAD_LEN * 0.5)) {
          farEnough = false; break;
        }
      }
      if (farEnough) addPowerBoxAt(seg.x, seg.z);
    }
  }
}




function addRoadblockAt(x, z, isX = true) {
  let block;
    // --- NEW: never spawn a roadblock on the goal/rescue ---
  // "2.5" gives the center point a little extra buffer inside the exclusion box.
  if (isInsideGoalNoSpawn(x, z, 2.5)) return null;

  if (RUBBISH_PREFAB) {
    block = RUBBISH_PREFAB.clone(true);
    block.position.set(x, 0, z);
    // Optional subtle variety:
    block.rotation.y = (Math.PI/2) * (Math.random()*4|0);
    const s = THREE.MathUtils.lerp(0.9, 1.15, Math.random());
    block.scale.multiplyScalar(s);
  } else {
    // Fallback simple box if model didn’t load
    const width = ROAD_WIDTH + 2.0, thickness = 0.6, height = 0.9;
    const mat = new THREE.MeshStandardMaterial({ color: 0xa33a3a, metalness: 0.1, roughness: 0.9 });
    const geo = isX ? new THREE.BoxGeometry(width, height, thickness)
                    : new THREE.BoxGeometry(thickness, height, width);
    block = new THREE.Mesh(geo, mat);
    block.position.set(x, BASE_HEIGHT + height/2, z);
    block.castShadow = block.receiveShadow = true;
  }

  scene.add(block);
  obstacles.push({ mesh:block, aabb: makeAABBFor(block), center: { x, z } });
  return block;
}

function spawnRoadblockAhead() {
  const forward = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);
  const ahead = car.position.clone().addScaledVector(forward, 24);
  const xDominant = Math.abs(forward.x) >= Math.abs(forward.z);
  addRoadblockAt(ahead.x, ahead.z, xDominant);
}

function spawnGlassAhead() {
  // Spawn a smashed-glass patch 18–32m in front of the car
  const forward = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);
  const dist = 18 + Math.random() * 14;
  const ahead = car.position.clone().addScaledVector(forward, dist);
  addGlassAt(ahead.x, ahead.z);
}

/* ===== Dynamic obstacle spawners (aggressive) ===== */
let rbTimer = 0, glassTimer = 0;
// Start with short intervals, then jitter each spawn
let rbPeriod = 1.2;     // seconds between roadblocks (randomized later)
let glassPeriod = 0.9;  // seconds between glass spawns (randomized later)

// Hard caps so we don't tank performance
const MAX_OBSTACLES = 80;   // trash/rubbish roadblocks
const MAX_GLASS     = 80;   // smashed-glass patches

function removeOldestObstacle(){
  const o = obstacles.shift();
  if (o) scene.remove(o.mesh);
}
function removeOldestGlass(){
  const g = glassHazards.shift();
  if (g) scene.remove(g.mesh);
}



/* ===================== Drone prefab (for pursuers) ===================== */
let DRONE_PREFAB = null;
let DRONE_RADIUS = 0.9;

async function loadDronePrefab() {
  // Try candidate filenames in order
  for (const name of DRONE_CANDIDATES) {
    const ok = await new Promise((resolve) => {
      new GLTFLoader().setPath(VEHICLE_PATH).load(
        name,
        (gltf) => {
          const root = gltf.scene;
          root.traverse(o => {
            if (o.isMesh) {
              o.castShadow = o.receiveShadow = true;
              if (o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
              if (o.material && 'metalness' in o.material && 'roughness' in o.material) {
                o.material.metalness = Math.min(0.6, o.material.metalness ?? 0.3);
                o.material.roughness = Math.max(0.35, o.material.roughness ?? 0.6);
              }
            }
          });

          // Scale the drone so its longest dimension ~ 2.0
          let box = new THREE.Box3().setFromObject(root);
          const size = new THREE.Vector3(); box.getSize(size);
          const longest = Math.max(size.x, size.y, size.z);
          const targetLongest = 2.0;
          const s = targetLongest / Math.max(1e-6, longest);
          root.scale.setScalar(s);

          box = new THREE.Box3().setFromObject(root);
          // Set base to ground, we will offset up a bit to hover
          root.position.y = -box.min.y;

          // radius from plan view
          DRONE_RADIUS = Math.max(0.6, Math.max(box.max.z - box.min.z, box.max.x - box.min.x) * 0.5 * 0.55);
          DRONE_PREFAB = root;
          resolve(true);
        },
        undefined,
        () => resolve(false)
      );
    });
    if (ok) return true;
  }
  console.warn('Drone GLB not found in assets/. Using fallback primitive.');
  return false;
}

/* ===================== Explosion FX ===================== */
const activeExplosions = [];
function spawnExplosion(pos) {
  const count = 120;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(count*3);
  const velocities = new Float32Array(count*3);
  const lifetimes = new Float32Array(count);
  for (let i=0;i<count;i++){
    positions[3*i+0]=pos.x;
    positions[3*i+1]=pos.y+0.6;
    positions[3*i+2]=pos.z;
    // random spherical velocity
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);
    const speed = 6.0 * (0.5 + Math.random());
    velocities[3*i+0]= speed*Math.sin(phi)*Math.cos(theta);
    velocities[3*i+1]= speed*Math.cos(phi)*0.8 + 1.5; // bias upward a bit
    velocities[3*i+2]= speed*Math.sin(phi)*Math.sin(theta);
    lifetimes[i] = 0;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geo.setAttribute('velocity', new THREE.BufferAttribute(velocities,3));
  geo.setAttribute('life', new THREE.BufferAttribute(lifetimes,1));

  const mat = new THREE.PointsMaterial({
    size: 0.12,
    transparent: true,
    opacity: 0.95,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    color: 0xffcc66
  });
  const points = new THREE.Points(geo, mat);
  points.userData.birth = performance.now();
  scene.add(points);
  activeExplosions.push(points);
  // auto-destroy after 900ms
  setTimeout(()=>{
    scene.remove(points);
    points.geometry.dispose();
    if (points.material.dispose) points.material.dispose();
    const idx = activeExplosions.indexOf(points);
    if (idx>=0) activeExplosions.splice(idx,1);
  }, 900);
}
function updateExplosions(dt){
  for (const p of activeExplosions){
    const g = p.geometry;
    const pos = g.getAttribute('position');
    const vel = g.getAttribute('velocity');
    const life = g.getAttribute('life');
    for (let i=0;i<life.count;i++){
      // simple Euler integration with slight drag + gravity
      vel.array[3*i+0] *= 0.96;
      vel.array[3*i+1] = vel.array[3*i+1]*0.96 - 9.8*dt*0.35;
      vel.array[3*i+2] *= 0.96;
      pos.array[3*i+0] += vel.array[3*i+0]*dt;
      pos.array[3*i+1] += vel.array[3*i+1]*dt;
      pos.array[3*i+2] += vel.array[3*i+2]*dt;
      life.array[i] += dt;
    }
    pos.needsUpdate = true;
    // fade over time
    const mat = p.material;
    if (mat.opacity !== undefined) {
      mat.opacity = Math.max(0, 0.95 - (performance.now()-p.userData.birth)/900);
    }
  }
}

/* ===================== Pursuer agents (drones) ===================== */

/* ===== Drone chase tuning ===== */
/* ===== Drone (constant-speed) tuning ===== */
const DRONE_REL_SPAWN   = 0.90; // when spawning, lock at ~97% of player's *current* speed
// Drones ignore world/building/obstacle collisions (still collide with the player)
const DRONES_PHASE = true;

const DRONE_CRUISE_MIN  = 16;   // absolute floor (units/s)
const DRONE_CRUISE_MAX  = 42;   // absolute cap (units/s)
const DRONE_ACCEL       = 25;   // accel used by steering (units/s^2)
const DRONE_LEAD_DIST   = 10;   // fixed lead distance in front of player (m)
const agents = [];
function spawnDrone(x, z) {
  let node, radius = 0.9;
  if (DRONE_PREFAB) {
    node = DRONE_PREFAB.clone(true);
    // Hover offset
    const hoverBase = 0.8;
    node.position.set(x, hoverBase, z);
    radius = DRONE_RADIUS;
  } else {
    // Fallback: disc-like drone
    const mesh = new THREE.Mesh(
      new THREE.CylinderGeometry(0.9, 1.1, 0.28, 24, 1, false),
      new THREE.MeshStandardMaterial({ color: 0x5469d4, metalness: 0.4, roughness: 0.5, emissive: 0x101838, emissiveIntensity: 0.2 })
    );
    mesh.position.set(x, 0.8, z);
    mesh.castShadow = mesh.receiveShadow = true;
    node = mesh;
    radius = 0.9;
  }

  // Soft glow core
  const glow = new THREE.PointLight(0x66ccff, 0.6, 10, 2);
  glow.position.set(0, 0.0, 0);
  node.add(glow);

  node.castShadow = true;
  scene.add(node);

  // lock a constant cruise speed when the drone is created
const initPlayerSpeed = Math.abs(speed);
const cruise = THREE.MathUtils.clamp(
  (initPlayerSpeed || DRONE_CRUISE_MIN) * DRONE_REL_SPAWN,
  DRONE_CRUISE_MIN,
  DRONE_CRUISE_MAX
);

const agent = {
  mesh: node,
  vel: new THREE.Vector3(),
  cruiseSpeed: cruise,         // <— constant per drone
  maxSpeed: cruise,            // steering uses this as the cap
  maxAccel: DRONE_ACCEL,       // stronger chase
  radius,
  isDrone: true,
  hoverPhase: Math.random()*Math.PI*2
};


  agents.push(agent);
  return agent;
}
function spawnDroneBehind() {
  const back = car.position.clone().add(new THREE.Vector3(-20, 0, 0));
  spawnDrone(back.x, back.z);
}
function spawnDroneNearPlayer(minDist=12, maxDist=20){
  const ang = Math.random()*Math.PI*2;
  const r = THREE.MathUtils.lerp(minDist, maxDist, Math.random());
  const x = car.position.x + Math.cos(ang)*r;
  const z = car.position.z + Math.sin(ang)*r;
  spawnDrone(x, z);
}

function avoidanceAccel(pos, maxAccel) {
  const aabbs = getNearbyAABBs(pos.x, pos.z, 40);
  const out = new THREE.Vector3();
  for (const b of aabbs) {
    const cx = THREE.MathUtils.clamp(pos.x, b.minX, b.maxX);
    const cz = THREE.MathUtils.clamp(pos.z, b.minZ, b.maxZ);
    let dx = pos.x - cx, dz = pos.z - cz;
    const d2 = dx*dx + dz*dz;
    const r = 2.4;
    if (d2 > 1e-6 && d2 < r*r) {
      const d = Math.sqrt(d2);
      const strength = (r - d) / r;
      dx /= d; dz /= d;
      out.x += dx * maxAccel * 1.2 * strength;
      out.z += dz * maxAccel * 1.2 * strength;
    }
  }
  return out;
}
function updateAgents(dt) {
  // Predict a point a fixed distance in front of the player (no speed coupling)
  const up = new THREE.Vector3(0, 1, 0);
  const carForward = new THREE.Vector3(1, 0, 0).applyAxisAngle(up, heading);
  const prediction = car.position.clone().addScaledVector(carForward, DRONE_LEAD_DIST);

  for (let i = agents.length - 1; i >= 0; i--) {
    const a = agents[i];
    if (!a.vel) a.vel = new THREE.Vector3();

    // --- CONSTANT SPEED: lock each drone to its cruise speed ---
    if (a.cruiseSpeed == null) {
      // fallback in case an old drone was spawned before we added cruiseSpeed
      a.cruiseSpeed = Math.max(DRONE_CRUISE_MIN, Math.min(DRONE_CRUISE_MAX, a.maxSpeed || DRONE_CRUISE_MIN));
    }
    a.maxSpeed = a.cruiseSpeed;   // cap is constant
    a.maxAccel = DRONE_ACCEL;     // strong steering accel

    // --- Seek the predicted point + avoid obstacles (XZ only) ---
    const desired = prediction.clone()
      .sub(new THREE.Vector3(a.mesh.position.x, car.position.y, a.mesh.position.z))
      .setY(0);

    const dist = desired.length();
    if (dist > 1e-6) desired.multiplyScalar(a.maxSpeed / dist);

    const avoid = DRONES_PHASE ? new THREE.Vector3() : avoidanceAccel(a.mesh.position, a.maxAccel);
    const steer = desired.sub(a.vel).add(avoid);
    const sl = steer.length(); if (sl > a.maxAccel) steer.multiplyScalar(a.maxAccel / sl);

    a.vel.addScaledVector(steer, dt);
    const vl = a.vel.length(); if (vl > a.maxSpeed) a.vel.multiplyScalar(a.maxSpeed / vl);

    // integrate on ground plane, then resolve circle collisions
    const proposed2D = new THREE.Vector3(a.mesh.position.x, 0, a.mesh.position.z)
  .addScaledVector(new THREE.Vector3(a.vel.x, 0, a.vel.z), dt);

// If phasing, accept the move directly; otherwise, resolve against buildings/obstacles
const fixed2D = DRONES_PHASE ? proposed2D : resolveCircleCollisions(proposed2D, a.radius);

a.mesh.position.x = fixed2D.x;
a.mesh.position.z = fixed2D.z;


    if (a.vel.lengthSq() > 0.01) a.mesh.rotation.y = Math.atan2(a.vel.z, a.vel.x);

    // hover/bob
    if (a.isDrone) {
      a.hoverPhase += dt * 2.5;
      a.mesh.position.y = 0.8 + Math.sin(a.hoverPhase) * 0.12;
    }
  }
}


/* ========= Car ↔ Drone collisions + player damage + explosion/respawn ========= */
let health = 100;
const DAMAGE_COOLDOWN_MS = 700;
let nextDamageAt = 0;
const healthUI = { wrap: document.getElementById('healthUI'), fill: document.getElementById('healthFill') };
function setHealthBar(h){ h = Math.max(0, Math.min(100, h)); const hue = (h * 120) / 100; healthUI.fill.style.width = `${h}%`; healthUI.fill.style.background = `hsl(${hue}, 78%, 45%)`; }
setHealthBar(health);
function flashDamage(){ healthUI.wrap.classList.add('hp-damage'); setTimeout(()=> healthUI.wrap.classList.remove('hp-damage'), 140); }
function applyDamage(amount){ if (health<=0) return; health = Math.max(0, health - amount); setHealthBar(health); flashDamage(); if (health===0) showToast('vehicle disabled!', 2500); }
let carVelVec = new THREE.Vector3();

function removeAgent(agent){
  const idx = agents.indexOf(agent);
  if (idx >= 0) agents.splice(idx,1);
  scene.remove(agent.mesh);
}

function handleCarAgentCollisions(dt){
  const now = performance.now();
  for (let i=agents.length-1; i>=0; i--) {
    const a = agents[i];
    const dx = car.position.x - a.mesh.position.x;
    const dz = car.position.z - a.mesh.position.z;
    const d2 = dx*dx + dz*dz;
    const minDist = 0.9 + a.radius;

    if (d2 < minDist*minDist) {
      let d = Math.sqrt(Math.max(d2, 1e-12));
      let nx = dx / d, nz = dz / d;

      const overlap = (minDist - d);
      car.position.x += nx * (overlap * 0.5);
      car.position.z += nz * (overlap * 0.5);
      a.mesh.position.x -= nx * (overlap * 0.5);
      a.mesh.position.z -= nz * (overlap * 0.5);

      a.vel.x -= nx * 6.5;
      a.vel.z -= nz * 6.5;

      const impactAlong = carVelVec.x * nx + carVelVec.z * nz;
      if (impactAlong > 0) speed = Math.max(0, speed - Math.min(impactAlong, 4.0));

      if (now >= nextDamageAt) {
        const relNx = (carVelVec.x - a.vel.x) * nx + (carVelVec.z - a.vel.z) * nz;
        const relSpd = Math.abs(relNx);
        const dmg = THREE.MathUtils.clamp(4 + relSpd * 0.9, 6, 18);
        applyDamage(dmg|0);
        nextDamageAt = now + DAMAGE_COOLDOWN_MS;
      }

      // === Drone-specific: explode, remove, and respawn nearby ===
      playExplosionSfx();  //  play your 'drone-explosion.wav'
      spawnExplosion(a.mesh.position.clone());
      removeAgent(a);
      spawnDroneNearPlayer(12, 20);
    }
  }
}

/* ===================== Interconnected grid of roads ===================== */
const PERIOD = 3*ROAD_LEN + XWALK_LEN;
function makeCenters(min,max){ const first=min + ROAD_LEN*3.5 + XWALK_LEN/2; const last=max - (ROAD_LEN + XWALK_LEN/2); const arr=[]; for(let c=first; c<=last+1e-6; c+=PERIOD) arr.push(c); return arr; }
const xs = makeCenters(-MAP_HALF, +MAP_HALF);
const zs = makeCenters(-MAP_HALF, +MAP_HALF);

// Snap any coordinate to the nearest actual road column/row
function nearestGridX(x){
  let best = xs[0], bestD = Infinity;
  for (const v of xs){ const d=Math.abs(v-x); if (d<bestD){ bestD=d; best=v; } }
  return best;
}
function nearestGridZ(z){
  let best = zs[0], bestD = Infinity;
  for (const v of zs){ const d=Math.abs(v-z); if (d<bestD){ bestD=d; best=v; } }
  return best;
}


function placeCrosswalk(x,z,rot90=false){ const m = createCrosswalkTile({ length:XWALK_LEN + 2*JOIN_EPS, width:ROAD_WIDTH + 2*JOIN_EPS, baseHeight:BASE_HEIGHT }); m.position.set(x,0,z); if (rot90) m.rotation.y=Math.PI/2; scene.add(m); }
function placeThreeRoadsX(x1,x2,z){ const L=ROAD_LEN+JOIN_EPS; const start=x1+(XWALK_LEN/2)+(ROAD_LEN/2)-JOIN_EPS/2; for(let i=0;i<3;i++){ const cx=start + i*ROAD_LEN; const r=createRoadTile({length:L,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.position.set(cx,0,z); scene.add(r); rememberSegment(cx,z,true); } }
function placeThreeRoadsZ(z1,z2,x){ const L=ROAD_LEN+JOIN_EPS; const start=z1+(XWALK_LEN/2)+(ROAD_LEN/2)-JOIN_EPS/2; for(let i=0;i<3;i++){ const cz=start + i*ROAD_LEN; const r=createRoadTile({length:L,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.rotation.y=Math.PI/2; r.position.set(x,0,cz); scene.add(r); rememberSegment(x,cz,false); } }
for (const z of zs){ xs.forEach(x=>placeCrosswalk(x,z)); for(let i=0;i<xs.length-1;i++) placeThreeRoadsX(xs[i], xs[i+1], z); }
for (const x of xs){ for(let j=0;j<zs.length-1;j++) placeThreeRoadsZ(zs[j], zs[j+1], x); }
for (const z of zs){
  const firstX=xs[0], lastX=xs.at(-1);
  let cx=firstX-(XWALK_LEN/2)-(ROAD_LEN/2)+JOIN_EPS/2;
  for(let i=0;i<3;i++){ const x=cx - i*ROAD_LEN; const r=createRoadTile({length:ROAD_LEN+JOIN_EPS,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.position.set(x,0,z); scene.add(r); rememberSegment(x,z,true); }
  cx=lastX+(XWALK_LEN/2)+(ROAD_LEN/2)-JOIN_EPS/2;
  for(let i=0;i<3;i++){ const x=cx + i*ROAD_LEN; const r=createRoadTile({length:ROAD_LEN+JOIN_EPS,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.position.set(x,0,z); scene.add(r); rememberSegment(x,z,true); }
}
for (const x of xs){
  const firstZ=zs[0], lastZ=zs.at(-1);
  let cz=firstZ-(XWALK_LEN/2)-(ROAD_LEN/2)+JOIN_EPS/2;
  for(let i=0;i<3;i++){ const z=cz - i*ROAD_LEN; const r=createRoadTile({length:ROAD_LEN+JOIN_EPS,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.rotation.y=Math.PI/2; r.position.set(x,0,z); scene.add(r); rememberSegment(x,z,false); }
  cz=lastZ+(XWALK_LEN/2)+(ROAD_LEN/2)-JOIN_EPS/2;
  for(let i=0;i<3;i++){ const z=cz + i*ROAD_LEN; const r=createRoadTile({length:ROAD_LEN+JOIN_EPS,width:ROAD_WIDTH,baseHeight:BASE_HEIGHT}); r.rotation.y=Math.PI/2; r.position.set(x,0,z); scene.add(r); rememberSegment(x,z,false); }
}

/* ===================== Spawn (car) ===================== */
const spawnZ = zs[Math.floor(zs.length/2)];
const firstRoadStartX = (-MAP_HALF) + ROAD_LEN;
const carStartX = firstRoadStartX - 0.4*ROAD_LEN;
let firstPerson = true;
let thirdPersonFront = false;   // when true, third-person camera is in front of the car
let heading = 0;
// Third-person free-orbit (RMB) state
let tpOrbiting = false;
let orbitYaw   = Math.PI;                               // 180° = behind by default
let orbitPitch = THREE.MathUtils.degToRad(25);          // slight downward view
let orbitDist  = 7.2;                                   // meters
car.position.set(carStartX, 0, spawnZ);
car.rotation.y = heading;



/* ===================== Warehouse behind the car ===================== */
function loadOBJ(path, obj){ return new Promise((res,rej)=> new OBJLoader().setPath(path).load(obj,res,undefined,rej)); }
const WAREHOUSE_DISTANCE_BEHIND = 40, WAREHOUSE_TARGET_LONGEST = 60;
loadOBJ(WH_PATH, WH_OBJ).then((wh)=>{
  wh.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; if(!o.material) o.material=new THREE.MeshLambertMaterial({ color:0x888888 }); } });
  const box=new THREE.Box3().setFromObject(wh); const size=new THREE.Vector3(); box.getSize(size);
  const s= WAREHOUSE_TARGET_LONGEST / Math.max(1e-6, Math.max(size.x,size.y,size.z)); wh.scale.setScalar(s);
  const box2=new THREE.Box3().setFromObject(wh); wh.position.y = -box2.min.y; wh.position.x = carStartX - WAREHOUSE_DISTANCE_BEHIND; wh.position.z = spawnZ; scene.add(wh);
}).catch(()=>console.warn('Could not load warehouse OBJ.'))  ;

/* ===================== Minimap ===================== */
const mm = document.getElementById('minimap');
const mmCtx = mm.getContext('2d', { alpha: true });
function resizeMinimap(){ const dpr=Math.min(2, window.devicePixelRatio||1); const cssW=mm.clientWidth, cssH=mm.clientHeight; mm.width=Math.round(cssW*dpr); mm.height=Math.round(cssH*dpr); mmCtx.setTransform(dpr,0,0,dpr,0,0); }
resizeMinimap(); addEventListener('resize', resizeMinimap);
const MINIMAP_SCALE=1.8; const MINIMAP_RADIUS = ()=> Math.min(mm.clientWidth, mm.clientHeight)*0.5;
let mmVisibleSegments=[]; let mmLastFilter=0; const MM_FILTER_HZ=150; const MM_DRAW_HZ=66; let mmLastDraw=0;
function refreshVisibleSegments(){
  const now=performance.now(); if (now - mmLastFilter < MM_FILTER_HZ) return; mmLastFilter = now;
  const Rw=(MINIMAP_RADIUS()/MINIMAP_SCALE)+8; const cx=car.position.x, cz=car.position.z; const L=ROAD_LEN+JOIN_EPS;
  mmVisibleSegments=[];
  for(const s of roadSegments){
    if (Math.abs(s.x - cx) > Rw + L/2) continue;
    if (Math.abs(s.z - cz) > Rw + L/2) continue;
    const dx=s.x-cx, dz=s.z-cz; if ((dx*dx + dz*dz) > (Rw+L/2)*(Rw+L/2)) continue;
    mmVisibleSegments.push(s);
  }
}
function drawMinimap(){
  const now = performance.now();
  if (now - mmLastDraw < MM_DRAW_HZ) return;
  mmLastDraw = now;

  const w = mm.clientWidth, h = mm.clientHeight;
  const cx = w/2, cz = h/2;

  mmCtx.clearRect(0, 0, w, h);

  // circular mask
  mmCtx.save();
  mmCtx.beginPath();
  mmCtx.arc(cx, cz, MINIMAP_RADIUS(), 0, Math.PI * 2);
  mmCtx.clip();

  // background
  mmCtx.fillStyle = '#202326';
  mmCtx.fillRect(0, 0, w, h);

  const carX = car.position.x, carZ = car.position.z;

  // roads
  mmCtx.strokeStyle = 'rgba(210,210,210,0.85)';
  mmCtx.lineCap = 'round';
  const roadHalfW = (ROAD_WIDTH * MINIMAP_SCALE) * 0.33;
  mmCtx.lineWidth = Math.max(2, roadHalfW);

  const L = ROAD_LEN + JOIN_EPS;
  for (const s of mmVisibleSegments){
    if (s.isX){
      const x1 = (s.x - L/2 - carX) * MINIMAP_SCALE + cx;
      const x2 = (s.x + L/2 - carX) * MINIMAP_SCALE + cx;
      const z  = (s.z - carZ)        * MINIMAP_SCALE + cz;
      mmCtx.beginPath(); mmCtx.moveTo(x1, z); mmCtx.lineTo(x2, z); mmCtx.stroke();
    } else {
      const z1 = (s.z - L/2 - carZ) * MINIMAP_SCALE + cz;
      const z2 = (s.z + L/2 - carZ) * MINIMAP_SCALE + cz;
      const x  = (s.x - carX)       * MINIMAP_SCALE + cx;
      mmCtx.beginPath(); mmCtx.moveTo(x, z1); mmCtx.lineTo(x, z2); mmCtx.stroke();
    }
  }

  // ----- breadcrumb trail (blue polyline + soft dots) -----
  if (MINI_TRAIL && MINI_TRAIL.length > 1){
    // polyline
    mmCtx.beginPath();
    for (let i = 0; i < MINI_TRAIL.length; i++){
      const sx = (MINI_TRAIL[i].x - carX) * MINIMAP_SCALE + cx;
      const sz = (MINI_TRAIL[i].y - carZ) * MINIMAP_SCALE + cz; // Vector2.y stores world Z
      if (i === 0) mmCtx.moveTo(sx, sz); else mmCtx.lineTo(sx, sz);
    }
    mmCtx.lineWidth = 3;
    mmCtx.strokeStyle = '#5ec8ff';
    mmCtx.globalAlpha = 0.95;
    mmCtx.stroke();
    mmCtx.globalAlpha = 1.0;

    // dotted glow (every 2nd point)
    for (let i = 0; i < MINI_TRAIL.length; i += 2){
      const sx = (MINI_TRAIL[i].x - carX) * MINIMAP_SCALE + cx;
      const sz = (MINI_TRAIL[i].y - carZ) * MINIMAP_SCALE + cz;
      mmCtx.beginPath();
      mmCtx.arc(sx, sz, 2, 0, Math.PI * 2);
      mmCtx.fillStyle = '#9bdcff';
      mmCtx.fill();
    }
  }

    // ----- pursuer drones (red dots) -----
  // Renders each agent with .isDrone === true as a red dot on the minimap.
  for (const a of agents) {
    if (!a?.mesh || !a.isDrone) continue;

    // Convert world → minimap space (centered on the car)
    const sx = (a.mesh.position.x - carX) * MINIMAP_SCALE + cx;
    const sz = (a.mesh.position.z - carZ) * MINIMAP_SCALE + cz;

    // Skip if outside the circular mask for a small perf win
    const dx = sx - cx, dz = sz - cz;
    const r = MINIMAP_RADIUS() - 2;
    if (dx*dx + dz*dz > r*r) continue;

    mmCtx.beginPath();
    mmCtx.arc(sx, sz, 4, 0, Math.PI * 2);
    mmCtx.fillStyle = '#ff4d4f';           // red
    mmCtx.shadowColor = 'rgba(0,0,0,0.45)';// soft drop-shadow like the player dot
    mmCtx.shadowBlur = 6;
    mmCtx.fill();
  }


  // player dot
  mmCtx.save();
  mmCtx.beginPath();
  mmCtx.arc(cx, cz, 7, 0, Math.PI * 2);
  mmCtx.fillStyle = '#17c964';
  mmCtx.shadowColor = 'rgba(0,0,0,0.45)';
  mmCtx.shadowBlur = 6;
  mmCtx.fill();
  mmCtx.lineWidth = 2;
  mmCtx.strokeStyle = 'rgba(0,0,0,0.35)';
  mmCtx.stroke();
  mmCtx.restore();

  // rim
  mmCtx.beginPath();
  mmCtx.arc(cx, cz, MINIMAP_RADIUS() - 1, 0, Math.PI * 2);
  mmCtx.strokeStyle = 'rgba(255,255,255,0.06)';
  mmCtx.lineWidth = 2;
  mmCtx.stroke();

  mmCtx.restore();
}


/* ===================== Parcel drop + toast ===================== */
function showToast(message, ms=3000){ const t=document.getElementById('toast'); t.textContent=message; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), ms); }
function dropParcel(){
  const el=document.createElement('div'); el.className='parcel'; document.body.appendChild(el);
  requestAnimationFrame(()=>{ el.style.transform=`translateY(${window.innerHeight+80}px)`; el.style.opacity='0'; });
  el.addEventListener('transitionend', ()=>{ el.remove(); showToast('parcel received, head to the destination', 3000); }, { once:true });
}

// --- SFX: drone explosion (separate instance each time so overlaps work) ---
const EXPLOSION_SFX_PATH = 'assets/sounds/drone-explosion.wav';
function playExplosionSfx() {
  const s = new Audio(EXPLOSION_SFX_PATH);
  s.volume = 0.7;  // tweak loudness
  s.play().catch(()=>{}); // ignore autoplay race conditions
}

// --- SFX: button click ---
const BUTTON_CLICK_SFX_PATH = 'assets/sounds/button-click.mp3';
function playButtonClickSfx() {
  const s = new Audio(BUTTON_CLICK_SFX_PATH);
  s.volume = 0.5; // adjust to taste
  s.play().catch(()=>{}); // ignore autoplay errors
}

// --- SFX: goal reached ---
const SUCCESS_SFX_PATH = 'assets/sounds/success-sound.wav';
function playSuccessSfx() {
  const s = new Audio(SUCCESS_SFX_PATH);
  s.volume = 0.7; // tweak to taste
  s.play().catch(()=>{}); // ignore autoplay race conditions
}




/* ===================== Helpers ===================== */
function getNearbyAABBs(cx, cz, radius = 50) {
  const out = [];
  for (const [key, pair] of active) {
    const parts = key.split(':');
    const px = Number(parts[1]), pz = Number(parts[2]);
    if ((cx - px)**2 + (cz - pz)**2 > radius*radius) continue;
    const b1 = new THREE.Box3().setFromObject(pair.b1); out.push(box3ToAABB2D(b1));
    const b2 = new THREE.Box3().setFromObject(pair.b2); out.push(box3ToAABB2D(b2));
  }

    // Streetlamps
  for (const l of lampColliders) {
    const dx = cx - l.center.x, dz = cz - l.center.z;
    if (dx*dx + dz*dz <= radius*radius) out.push(l.aabb);
  }

  for (const o of obstacles) {
    const dx = cx - o.center.x, dz = cz - o.center.z;
    if (dx*dx + dz*dz <= radius*radius) out.push(o.aabb);
  }
  return out;
}
function resolveCircleCollisions(pos, radius) {
  for (let it=0; it<4; it++) {
    const aabbs = getNearbyAABBs(pos.x, pos.z, 60);
    let pushed = false;
    for (const a of aabbs) {
      const push = circleAABBResolve(pos.x, pos.z, radius, a);
      if (push) { pos.x += push.x; pos.z += push.z; pushed = true; }
    }
    if (!pushed) break;
  }
  return pos;
}
function resolveCarCollisions(proposed) {
  // While ghosted, don’t push the car out of AABBs (buildings/blocks)
  if (isGhostActive()) return proposed;
  return resolveCircleCollisions(proposed, 0.8);
}


/* ===================== Bootstrap flow ===================== */
async function bootstrap(){
  const small = await loadGLB(BLD_PATH, SMALL_GLB);
  if (small) { SMALL_PREFAB=small.root; SMALL_H=small.height; }

  // Load pursuer drone
  await loadDronePrefab();

  // Load rubbish obstacle model
  await loadRubbishPrefab();

    // Load glass hazard prefab
  await loadGlassPrefab();

    // Load street light prefab
  await loadStreetLightPrefab();

    // Load the goal flag model
  await loadGoalPrefab();

    // Load rescue person model
  await loadRescuePrefab();


    // Load power box prefab
  await loadPowerBoxPrefab();

// === Apply concrete texture to NON-ROAD ground (robust baseline) ===
{
  const loader = new THREE.TextureLoader();
  const url = 'textures/textures/concrete_pavement_diff_4k.jpg';


  // 1) start with a visible, lighting-independent baseline (cannot be black)
  ground.material = new THREE.MeshBasicMaterial({ color: 0x666666 }); // DEBUG baseline
  ground.material.needsUpdate = true;

  // 2) now try to load & apply the texture; keep BasicMaterial so lighting can't make it black
  loader.load(
    url,
    (tex) => {
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(60, 60);
      // optional: crisper at glancing angles
      if (renderer.capabilities.getMaxAnisotropy) {
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      }

      // Use Basic to prove the texture shows up regardless of lights/shadows
      ground.material = new THREE.MeshBasicMaterial({ map: tex });
      ground.material.needsUpdate = true;
    },
    undefined,
    // 3) if the image path is wrong, keep the grey so it's still visible
    (err) => {
      console.warn('Ground texture failed to load:', url, err);
      ground.material = new THREE.MeshBasicMaterial({ color: 0x777777 });
      ground.material.needsUpdate = true;
    }
  );

  // keep it slightly below roads (no BASE_HEIGHT reference → no TDZ)
  ground.position.y = ground.position.y - 0.005;
}

  


  // Create a destination & breadcrumb trail
  //spawnGoalAndTrail();
  




  // Seed some buildings nearby
  const initialRadius=200;
  for (const s of roadSegments){ const d=Math.hypot(car.position.x - s.x, car.position.z - s.z); if (d<initialRadius && !active.has(segKey(s))) spawnPair(s,true); }

  // Load large building and enable streaming
  loadGLB(BLD_PATH, LARGE_GLB).then(res=>{
    if (res) { LARGE_PREFAB=res.root; LARGE_H=res.height; }
    streamingEnabled=true;
  }).catch(()=>{ streamingEnabled=true; });

  /*
  // Demo obstacles + one drone
  addRoadblockAt(carStartX + ROAD_LEN*1.5, spawnZ, true);
  addRoadblockAt(carStartX + ROAD_LEN*3.0, spawnZ, true);
  spawnDrone(carStartX - 30, spawnZ);

    // Example hazard near spawn
  addGlassAt(carStartX + ROAD_LEN*2, spawnZ);
  */

}

bootstrap();

/* ===================== Controls & movement ===================== */
const keys=new Set();
// Map WASD only while the reversed-controls effect is active
function mapReversedCode(code) {
  if (!isReversedActive()) return code;
  if (code === 'KeyW') return 'KeyS';
  if (code === 'KeyS') return 'KeyW';
  if (code === 'KeyA') return 'KeyD';
  if (code === 'KeyD') return 'KeyA';
  return code;
}

addEventListener('keydown', (e) => {
  // keep your original preventDefault list
  if (['KeyW','KeyA','KeyS','KeyD','KeyC','KeyL','KeyN','KeyH','KeyR','KeyP','KeyB','KeyE','KeyZ'].includes(e.code)) e.preventDefault();
  keys.add(mapReversedCode(e.code));
});

addEventListener('keyup', (e) => {
  keys.delete(mapReversedCode(e.code));
});


// ===== Third-person free-orbit with RMB =====
let lastMX = 0, lastMY = 0;

addEventListener('contextmenu', (e)=> e.preventDefault()); // disable RMB menu over canvas

addEventListener('mousedown', (e)=>{
  if (e.button !== 2) return;           // only right mouse button
  if (firstPerson) return;              // only in 3rd-person
  tpOrbiting = true;

  // Initialize orbit angles from current camera position around the car
  const target = car.position.clone().add(new THREE.Vector3(0, 0.9, 0));
  const rel = camera.position.clone().sub(target);
  const rxy = Math.hypot(rel.x, rel.z);
  orbitYaw   = Math.atan2(rel.z, rel.x);          // around Y
  orbitPitch = Math.atan2(rel.y, rxy);            // up/down
  orbitDist  = Math.max(2.5, rel.length());       // keep current distance

  lastMX = e.clientX; lastMY = e.clientY;
});

addEventListener('mousemove', (e)=>{
  if (!tpOrbiting) return;
  const dx = e.clientX - lastMX;
  const dy = e.clientY - lastMY;
  lastMX = e.clientX; lastMY = e.clientY;

  const YAW_SENS   = 0.0032;
  const PITCH_SENS = 0.0025;

  orbitYaw   -= dx * YAW_SENS;                                // drag left/right
  orbitPitch = THREE.MathUtils.clamp(                         // drag up/down
    orbitPitch - dy * PITCH_SENS,
    THREE.MathUtils.degToRad(-5),  // don’t go below horizon too much
    THREE.MathUtils.degToRad(80)   // don’t flip over the top
  );
});

addEventListener('mouseup', (e)=>{
  if (e.button === 2) tpOrbiting = false;
});

// Optional: zoom while orbiting with the wheel (ignored when not orbiting)
addEventListener('wheel', (e)=>{
  if (!tpOrbiting) return;
  orbitDist = THREE.MathUtils.clamp(orbitDist + Math.sign(e.deltaY) * 0.6, 3.5, 14.0);
}, { passive:true });


let speed=0; const params={ accel:8.0, brake:12.0, reverseAccel:6.0, maxFwd:14.0, maxRev:6.0, friction:3.5, steerRate:1.8, minSteerFactor:0.35 };
const camTarget=new THREE.Vector3(); const FP_EYE_OFFSET=new THREE.Vector3(0.05,1.55,0.12);

function update(dt){
  if (!gameStarted) return;

  if (paused) { speed = 0; return; }

  // End ghost mode when its timer is up
if (isGhostMode && !isGhostActive()) {
  endGhostMode();
}

// End reversed-controls when its timer is up
if (reversedControls && !isReversedActive()) {
  endReversed();
}




  // timer (only when playing)
if (!paused && timeLeft > 0) {
  timeLeft -= dt;
  updateObjectiveHUD();
  if (timeLeft <= 0) {
    endLevel(false);
    return; // stop further updates this frame (it will restart)
  }
}


  if (keys.has('KeyW')) speed += params.accel * dt;
  else if (keys.has('KeyS')) speed += (speed>0 ? -params.brake : -params.reverseAccel) * dt;
  else { const s=Math.sign(speed); speed -= s*params.friction*dt; if (Math.sign(speed)!==s) speed=0; }
  speed = THREE.MathUtils.clamp(speed, -params.maxRev, params.maxFwd);

  let steer=0; if (keys.has('KeyA')) steer += 1; if (keys.has('KeyD')) steer -= 1;
  const steerFactor = THREE.MathUtils.lerp(1.8, params.minSteerFactor, Math.min(Math.abs(speed)/params.maxFwd, 1));
  heading += params.steerRate * steerFactor * steer * dt;

  const forward = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), heading);

  // collision-aware movement
  const moveLen = speed*dt;
  const proposed = car.position.clone().addScaledVector(forward, moveLen);
  const fixed = resolveCarCollisions(proposed);
  const pushedDist = proposed.distanceTo(fixed);
  if (pushedDist > 0.0001 && moveLen > 0) speed = Math.max(0, speed - 8.0*dt);

  car.position.copy(fixed);
  car.rotation.set(0, heading, 0);

    // maintain a single lamp pair on the next straight segment in front of the car
  ensureAheadLampPair();


  // one-tap actions
  if (keys.has('KeyC')) { firstPerson = !firstPerson; keys.delete('KeyC'); }
  if (keys.has('KeyL')) { setStreetLights(!streetLightsOn); keys.delete('KeyL'); }
  if (keys.has('KeyH')) { setHeadlights(!headlightsOn); keys.delete('KeyH'); }
  if (keys.has('KeyR')) { keys.delete('KeyR'); /* reserved */ }
  if (keys.has('KeyP')) { dropParcel(); keys.delete('KeyP'); }
  if (keys.has('KeyB')) { spawnRoadblockAhead(); keys.delete('KeyB'); }
 // Z -> toggle between reverse (front camera looking back) and normal (behind)
// Always switch to third-person when Z is pressed.
if (keys.has('KeyZ')) {
  firstPerson = false;                    // ensure we're in 3rd person
  thirdPersonFront = !thirdPersonFront;   // <— toggle the view
  if (document.pointerLockElement) document.exitPointerLock();
  keys.delete('KeyZ');
}


if (keys.has('KeyV')) { thirdPersonFront = !thirdPersonFront; keys.delete('KeyV'); }


  if (keys.has('KeyE')) { spawnDroneBehind();    keys.delete('KeyE'); }

  if (keys.has('KeyN')) {
  keys.delete('KeyN');
  const toNight = sun.intensity > 0.3;
  if (toNight) setNight(); else setDay();
}


  updateStreaming(performance.now());

  // keep sun & shadow tight to the car
  sun.position.set(car.position.x + 25, car.position.y + 35, car.position.z + 10);
  const cam = sun.shadow.camera;
  cam.position.set(car.position.x, car.position.y + 20, car.position.z);
  cam.updateProjectionMatrix(); cam.updateMatrixWorld();

  // camera follow
  if (firstPerson) {
    const eye = FP_EYE_OFFSET.clone().applyAxisAngle(new THREE.Vector3(0,1,0), heading).add(car.position);
    camera.position.lerp(eye, 0.25);
    camTarget.copy(eye).addScaledVector(forward, 20); camTarget.y += 0.10; camera.lookAt(camTarget);
  } else {
  // Third-person: normal follow OR temporary free-orbit when RMB is held
  const target = camTarget.copy(car.position).add(new THREE.Vector3(0, 0.9, 0));

  if (tpOrbiting) {
    // Free-orbit around the car (doesn't affect driving)
    const cp = Math.cos(orbitPitch), sp = Math.sin(orbitPitch);
    const ox = Math.cos(orbitYaw) * orbitDist * cp;
    const oy = sp * orbitDist;
    const oz = Math.sin(orbitYaw) * orbitDist * cp;

    const desired = target.clone().add(new THREE.Vector3(ox, oy, oz));
    camera.position.lerp(desired, 0.18);      // smooth
    camera.lookAt(target);
  } else {
    // Normal follow (your existing behind/front views)
    const localOffset = thirdPersonFront
      ? new THREE.Vector3(+6.5, 2.8, 0.0)    // in front, looking back
      : new THREE.Vector3(-6.5, 3.0, 0.0);    // behind, looking forward
    const off = localOffset.applyAxisAngle(new THREE.Vector3(0,1,0), heading);

    camera.position.lerp(car.position.clone().add(off), 0.08);
    camera.lookAt(target);
  }
}

  // car velocity for collision math
  carVelVec.copy(forward).multiplyScalar(speed);

  // === Glass hazard slowdown ===
if (!isGhostActive()) {
  for (const g of glassHazards) {
    const aabb = g.aabb;
    if (
      car.position.x >= aabb.minX && car.position.x <= aabb.maxX &&
      car.position.z >= aabb.minZ && car.position.z <= aabb.maxZ
    ) {
      speed *= 0.92; // apply slowdown factor each frame on glass
    }
  }
}


    // ----- Dynamic obstacle spawning (runs while driving) -----
  // Only spawn when moving a bit (prevents spam while stationary in a corner)
  if (Math.abs(speed) > 2.0) {
    rbTimer += dt;
    glassTimer += dt;

    if (rbTimer >= rbPeriod) {
      // keep population under control
      if (obstacles.length >= MAX_OBSTACLES) removeOldestObstacle();
      spawnRoadblockAhead();
      rbTimer = 0;
      rbPeriod = THREE.MathUtils.randFloat(0.7, 1.4); // jitter next interval
    }

    if (glassTimer >= glassPeriod) {
      if (glassHazards.length >= MAX_GLASS) removeOldestGlass();
      spawnGlassAhead();
      glassTimer = 0;
      glassPeriod = THREE.MathUtils.randFloat(0.6, 1.2); // jitter next interval
    }
  }

  // enemies move + collisions + damage (+ explosions/respawn)
  updateAgents(dt);
  handleCarAgentCollisions(dt);

  // explosions update
  updateExplosions(dt);

  // === Goal arrival check ===
if (goalNode){
  const gx = goalNode.position.x, gz = goalNode.position.z;
  const dx = car.position.x - gx, dz = car.position.z - gz;
  if (dx*dx + dz*dz <= GOAL_REACH_RADIUS*GOAL_REACH_RADIUS) {
    onReachGoal();
  }
}

  // === Power box collection ===
  for (let i = powerBoxes.length - 1; i >= 0; i--) {
    const pb = powerBoxes[i];
    const a = pb.aabb;
      // use the car’s radius so grazing contact counts
  if (circleAABBResolve(car.position.x, car.position.z, CAR_RADIUS * 0.95, a)) {

      // collected!
      scene.remove(pb.mesh);
      powerBoxes.splice(i, 1);
      // random effect: Ghost / Reversed / Fog Vision (≈1/3 each)
const r = Math.random();
if (r < 1/3) {
  showToast('yellow box: GHOST MODE!', 1400);
  activateGhostMode(5000);
} else if (r < 2/3) {
  showToast('yellow box: REVERSED CONTROLS!', 1400);
  activateReversed(3000);
} else {
  showToast('yellow box: FOG VISION!', 1400);
  activateFog(4000);
}


    }
  }
  // Stream new yellow boxes along the path at long intervals
tickPowerBoxProgress();



// Health loss condition
if (health <= 0 && failUI.style.display === 'none') {
  showFailMenu('Vehicle destroyed!');
  return;
}



  // minimap
  refreshVisibleSegments(); drawMinimap();
}

/* ===================== Tick + adaptive resolution ===================== */
let last=performance.now(), dynDPR=START_DPR; const DPR_MIN=0.8, DPR_MAX=Math.min(2, START_DPR);
let fpsMeasureT=0, fpsFrames=0;
function tick(now=performance.now()){
  const dt=Math.min(0.033, (now-last)/1000); last=now;
  update(dt);
  // Keep the sky centered on the camera to avoid ever touching the far plane
sky.mesh.position.copy(camera.position);
  // --- Pulse the goal’s glow ring ---
  if (goalNode?.userData?.ring) {
    const t = performance.now() * 0.002;
    const s = 0.92 + Math.sin(t) * 0.08;
    goalNode.userData.ring.scale.setScalar(s);
  }

    // --- Animate goal beacon/flare for long-range visibility ---
  if (goalNode) {
    const t = performance.now() * 0.001;

    // Softly vary beam opacity
    const beam = goalNode.userData?.beam;
    if (beam && beam.material) {
      beam.material.opacity = 0.18 + 0.10 * (0.5 + 0.5 * Math.sin(t * 2.0));
      // (optional) tiny width wobble
      const s = 1.0 + 0.03 * Math.sin(t * 1.7);
      beam.scale.set(s, 1, s);
    }

    // Flare: face camera + subtle pulse
    const flare = goalNode.userData?.flare;
    if (flare && flare.material) {
      flare.material.opacity = 0.55 + 0.25 * Math.sin(t * 1.3);
      flare.lookAt(camera.position);
    }

    // (keep your ring pulse here if you added it earlier)
  }

    // --- Fog Vision: restore after timer ends (extra safety) ---
  if (!isFogActive() && fogBackup.active) {
    transitionFog(fogBackup.color.getHex(), fogBackup.density, 500);
    fogBackup.active = false;
  }


    // --- Fog Vision: restore after timer ends (extra safety) ---
  if (!isFogActive() && fogBackup.active) {
    transitionFog(fogBackup.color.getHex(), fogBackup.density, 500);
    fogBackup.active = false;

    // SHOW PATH again when fog ends
    setTrailVisible(true);
  }

   renderer.render(scene, camera);
  fpsFrames++; if(!fpsMeasureT) fpsMeasureT=now; const elapsed=now-fpsMeasureT;
  if (elapsed>500){ const fps=(fpsFrames*1000)/elapsed; fpsFrames=0; fpsMeasureT=now;
    if (fps<45 && dynDPR>DPR_MIN){ dynDPR=Math.max(DPR_MIN, dynDPR-0.1); renderer.setPixelRatio(dynDPR); }
    else if (fps>58 && dynDPR<DPR_MAX){ dynDPR=Math.min(DPR_MAX, dynDPR+0.1); renderer.setPixelRatio(dynDPR); }
  }
  requestAnimationFrame(tick);
}
tick();

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight); renderer.setPixelRatio(dynDPR);
  resizeMinimap();
});

// ===== Pause Menu Logic =====
const pauseMenu = document.getElementById('pauseMenu');
const btnQuitLevel = document.getElementById('btnQuitLevel');
const btnInstructions = document.getElementById('btnInstructions');
let isPaused = false;


// Toggle pause when ESC is pressed
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && gameStarted) {
    isPaused = !isPaused;
    pauseMenu.style.display = isPaused ? 'flex' : 'none';

    //  Pause or resume engine loop only (leave bgMusic playing)
    if (window.engineSound) {
      if (isPaused) engineSound.pause();
      else engineSound.play();
    }
  }
});



// Quit Level → return to Level Select
btnQuitLevel.addEventListener('click', () => {
  pauseMenu.style.display = 'none';
  isPaused = false;
  gameStarted = false;

  // Hide in-game HUDs
  document.getElementById('info').style.display = 'none';
  document.getElementById('healthUI').style.display = 'none';
  document.getElementById('minimap').style.display = 'none';
  document.getElementById('objectiveUI').style.display = 'none';

  // Show Level Select
  document.getElementById('levelSelect').style.display = 'flex';
   
  // Quit Level → return to Level Select
btnQuitLevel.addEventListener('click', () => {
  pauseMenu.style.display = 'none';
  isPaused = false;
  gameStarted = false;

  // Hide in-game HUDs
  document.getElementById('info').style.display = 'none';
  document.getElementById('healthUI').style.display = 'none';
  document.getElementById('minimap').style.display = 'none';
  document.getElementById('objectiveUI').style.display = 'none';

  // Show Level Select
  document.getElementById('levelSelect').style.display = 'flex';

  // 🔊 Stop engine sound completely when quitting (bgMusic keeps playing)
  if (window.engineSound) engineSound.pause();
});


});

// Instructions & Controls → open the same in-game modal as the home screen button
btnInstructions.addEventListener('click', () => {
  pauseMenu.style.display = 'none';
  isPaused = true; // keep game paused while modal is open

  const modalEl = document.getElementById('modal');
  const modalTitle = document.getElementById('modal-title');
  const modalContent = document.getElementById('modal-content');

  modalTitle.textContent = 'Instructions & Controls';
  modalContent.innerHTML = INSTRUCTIONS_HTML;
  modalEl.style.display = 'grid';
});



// Freeze updates while paused
const originalUpdate = update;
update = function (dt) {
  if (isPaused) return;
  originalUpdate(dt);
};

</script>
</body>
</html>
